# 高考祈福 Android 应用架构设计文档

## 文档信息
- **项目名称**: 高考祈福 Android 应用
- **文档版本**: v1.0
- **创建日期**: 2025年6月8日
- **架构模式**: MVVM (Model-View-ViewModel)
- **编程语言**: Java
- **目标平台**: Android (原生开发)

## 目录
1. [系统总体架构设计](#1-系统总体架构设计)
2. [技术选型方案](#2-技术选型方案)
3. [模块划分与职责](#3-模块划分与职责)
4. [核心类图与包结构](#4-核心类图与包结构)
5. [通信机制设计](#5-通信机制设计)
6. [数据存储方案](#6-数据存储方案)
7. [网络层架构](#7-网络层架构)
8. [依赖注入方案](#8-依赖注入方案)
9. [异常处理与日志策略](#9-异常处理与日志策略)
10. [安全与权限管理](#10-安全与权限管理)
11. [可测试性与可维护性](#11-可测试性与可维护性)
12. [构建配置与多环境支持](#12-构建配置与多环境支持)

---

## 1. 系统总体架构设计

### 1.1 架构概述

高考祈福Android应用采用**MVVM (Model-View-ViewModel)** 架构模式，结合**Repository模式**和**依赖注入**，构建一个**分层、解耦、可测试**的现代化Android应用架构。

### 1.2 架构层次图

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Activity  │  │  Fragment   │  │   Dialog    │        │
│  │   (View)    │  │   (View)    │  │   (View)    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│         │                │                │                │
│         └────────────────┼────────────────┘                │
│                          │                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   ViewModel Layer                       │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │ MainViewModel│  │BlessingViewModel│ │UserViewModel│  │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘    │ │
│  └─────────────────────────────────────────────────────────┘ │
│         │                │                │                │
│         └────────────────┼────────────────┘                │
│                          │                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                  Business Layer                         │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │ Repository  │  │  UseCase    │  │  Manager    │    │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘    │ │
│  └─────────────────────────────────────────────────────────┘ │
│         │                │                │                │
│         └────────────────┼────────────────┘                │
│                          │                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    Data Layer                           │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │ │
│  │  │ LocalData   │  │ RemoteData  │  │ SharedPref  │    │ │
│  │  │  (Room)     │  │ (Retrofit)  │  │             │    │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘    │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 架构分层说明

#### 1.3.1 Presentation Layer (表示层)
**职责**: 负责用户界面展示和用户交互处理
- **Activity**: 作为页面容器，管理Fragment生命周期
- **Fragment**: 具体的UI组件，承载用户界面
- **Dialog**: 弹窗组件，处理临时交互
- **Custom Views**: 自定义UI组件

**特点**:
- 只负责UI展示，不包含业务逻辑
- 通过Data Binding与ViewModel绑定
- 使用LiveData观察数据变化
- 支持配置变化时的状态保持

#### 1.3.2 ViewModel Layer (视图模型层)
**职责**: 连接View和Model，处理UI相关的业务逻辑
- **ViewModel**: 管理UI状态，处理用户交互
- **LiveData**: 提供可观察的数据容器
- **Data Binding**: 实现双向数据绑定

**特点**:
- 生命周期感知，自动处理内存泄漏
- 在配置变化时保持状态
- 不直接持有View引用
- 通过Repository获取数据

#### 1.3.3 Business Layer (业务层)
**职责**: 封装业务逻辑，协调数据操作
- **Repository**: 数据仓库，统一数据访问接口
- **UseCase**: 用例类，封装特定业务场景
- **Manager**: 管理类，处理复杂业务逻辑

**特点**:
- 单一职责原则
- 与UI层解耦
- 可复用的业务逻辑
- 便于单元测试

#### 1.3.4 Data Layer (数据层)
**职责**: 数据的存储、获取和管理
- **Local Data Source**: 本地数据源（Room数据库）
- **Remote Data Source**: 远程数据源（Retrofit网络请求）
- **Shared Preferences**: 轻量级键值对存储

**特点**:
- 数据源抽象，便于切换实现
- 缓存策略管理
- 数据一致性保证
- 离线支持

### 1.4 核心设计原则

#### 1.4.1 单一职责原则 (SRP)
- 每个类只负责一个功能
- 便于维护和测试
- 降低代码耦合度

#### 1.4.2 依赖倒置原则 (DIP)
- 高层模块不依赖底层模块
- 通过接口进行依赖
- 便于模块替换和测试

#### 1.4.3 开闭原则 (OCP)
- 对扩展开放，对修改关闭
- 通过继承和组合扩展功能
- 保持系统稳定性

#### 1.4.4 关注点分离
- UI逻辑与业务逻辑分离
- 数据访问与业务逻辑分离
- 便于并行开发和维护

### 1.5 数据流向

```
User Interaction → View → ViewModel → Repository → Data Source
                                  ↓
User Interface ← View ← ViewModel ← Repository ← Data Source
```

1. **用户交互**: 用户在View上进行操作
2. **事件传递**: View将事件传递给ViewModel
3. **业务处理**: ViewModel调用Repository处理业务逻辑
4. **数据获取**: Repository从Data Source获取数据
5. **数据返回**: 数据通过Repository返回给ViewModel
6. **UI更新**: ViewModel通过LiveData更新View

### 1.6 架构优势

#### 1.6.1 可维护性
- 清晰的分层结构
- 单一职责原则
- 代码模块化

#### 1.6.2 可测试性
- 依赖注入便于Mock
- 业务逻辑与UI分离
- 支持单元测试和集成测试

#### 1.6.3 可扩展性
- 松耦合设计
- 接口抽象
- 便于功能扩展

#### 1.6.4 可复用性
- Repository模式
- UseCase封装
- 组件化设计

#### 1.7 技术栈预览

| 层级 | 技术选型 | 说明 |
|------|----------|------|
| UI层 | Activity + Fragment + Data Binding | 界面展示和交互 |
| 视图模型层 | ViewModel + LiveData | 状态管理和数据绑定 |
| 业务层 | Repository + UseCase | 业务逻辑封装 |
| 数据层 | Room + Retrofit + SharedPreferences | 数据存储和网络请求 |
| 依赖注入 | Dagger 2 | 依赖管理 |
| 异步处理 | RxJava 2 | 响应式编程 |
| 图片加载 | Glide | 图片缓存和显示 |

---

## 2. 技术选型方案

### 2.1 核心框架选型

#### 2.1.1 UI框架
**选择**: Android Native + Data Binding + View Binding

**原因**:
- **原生性能**: 原生Android开发提供最佳性能和用户体验
- **完整生态**: 完全兼容Android生态系统和最新特性
- **团队熟悉度**: Java开发团队对Android原生开发更加熟悉
- **维护成本**: 长期维护成本较低，社区支持完善

**技术组合**:
```java
// Data Binding 实现双向数据绑定
@BindingAdapter("imageUrl")
public static void loadImage(ImageView view, String url) {
    Glide.with(view.getContext()).load(url).into(view);
}

// View Binding 替代 findViewById
public class MainActivity extends AppCompatActivity {
    private ActivityMainBinding binding;
}
```

#### 2.1.2 架构组件
**选择**: Android Architecture Components (AAC)

**核心组件**:
- **ViewModel**: 管理UI相关数据，支持配置变化
- **LiveData**: 可观察的数据持有者
- **Navigation Component**: 应用内导航管理
- **Room**: 本地数据库ORM
- **WorkManager**: 后台任务管理

**优势**:
- Google官方推荐
- 生命周期感知
- 配置变化时数据保持
- 内存泄漏防护

### 2.2 依赖注入框架

#### 2.2.1 Dagger 2
**选择原因**:
- **编译时检查**: 在编译时进行依赖检查，运行时性能优秀
- **代码生成**: 生成高效的依赖注入代码
- **模块化**: 支持模块化架构设计
- **社区成熟**: 广泛应用于企业级Android项目

**实现示例**:
```java
// Application级Component
@Singleton
@Component(modules = {AppModule.class, NetworkModule.class})
public interface AppComponent {
    void inject(MainActivity activity);
    Repository getRepository();
}

// 模块定义
@Module
public class NetworkModule {
    @Provides
    @Singleton
    public ApiService provideApiService() {
        return new Retrofit.Builder()
            .baseUrl(API_BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService.class);
    }
}
```

### 2.3 网络请求框架

#### 2.3.1 Retrofit 2 + OkHttp 3
**选择原因**:
- **声明式API**: 通过注解定义接口，代码简洁
- **类型安全**: 编译时类型检查
- **拦截器支持**: 灵活的请求/响应处理
- **缓存机制**: OkHttp提供强大的缓存功能

**技术配置**:
```java
// API接口定义
public interface BlessingApiService {
    @GET("blessings")
    Call<List<Blessing>> getBlessings(@Query("page") int page);
    
    @POST("blessings")
    Call<Blessing> createBlessing(@Body CreateBlessingRequest request);
    
    @PUT("blessings/{id}/like")
    Call<ResponseBody> likeBlessing(@Path("id") int blessingId);
}

// 网络配置
OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new AuthInterceptor())
    .addInterceptor(new LoggingInterceptor())
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .build();
```

### 2.4 响应式编程框架

#### 2.4.1 RxJava 2 + RxAndroid
**选择原因**:
- **异步处理**: 优雅处理复杂的异步操作
- **数据流管理**: 强大的数据流转换和组合能力
- **线程切换**: 简化线程间切换
- **错误处理**: 统一的错误处理机制

**应用场景**:
```java
// 数据流转换示例
public class BlessingRepository {
    public Observable<List<Blessing>> getBlessings() {
        return apiService.getBlessings()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .map(response -> response.getData())
            .onErrorResumeNext(throwable -> {
                return localDataSource.getBlessings();
            });
    }
}
```

### 2.5 数据存储解决方案

#### 2.5.1 Room Database
**选择原因**:
- **SQLite抽象层**: 提供编译时验证的SQL查询
- **LiveData集成**: 自动UI更新
- **迁移支持**: 数据库版本升级管理
- **类型转换**: 自动对象-关系映射

**数据库设计**:
```java
// 实体定义
@Entity(tableName = "blessings")
public class Blessing {
    @PrimaryKey
    public int id;
    
    @ColumnInfo(name = "content")
    public String content;
    
    @ColumnInfo(name = "author_name")
    public String authorName;
    
    @ColumnInfo(name = "created_at")
    public Date createdAt;
}

// DAO定义
@Dao
public interface BlessingDao {
    @Query("SELECT * FROM blessings ORDER BY created_at DESC")
    LiveData<List<Blessing>> getAllBlessings();
    
    @Insert
    void insertBlessing(Blessing blessing);
    
    @Delete
    void deleteBlessing(Blessing blessing);
}
```

#### 2.5.2 SharedPreferences 封装
**用途**: 用户设置、登录状态、应用配置
```java
public class PreferencesManager {
    private SharedPreferences preferences;
    
    public void setUserLogin(boolean isLogin) {
        preferences.edit().putBoolean("is_login", isLogin).apply();
    }
    
    public boolean isUserLogin() {
        return preferences.getBoolean("is_login", false);
    }
}
```

### 2.6 图片加载框架

#### 2.6.1 Glide 4
**选择原因**:
- **内存效率**: 智能的内存管理和缓存策略
- **生命周期集成**: 自动管理请求生命周期
- **格式支持**: 支持多种图片格式和动画
- **变换支持**: 丰富的图片变换功能

**使用配置**:
```java
// Glide配置
@GlideModule
public class MyGlideModule extends AppGlideModule {
    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        builder.setDefaultRequestOptions(
            RequestOptions.diskCacheStrategyOf(DiskCacheStrategy.ALL)
        );
    }
}

// 图片加载示例
Glide.with(context)
    .load(imageUrl)
    .placeholder(R.drawable.placeholder)
    .error(R.drawable.error)
    .transform(new CircleCrop())
    .into(imageView);
```

### 2.7 UI组件库

#### 2.7.1 Material Design Components
**选择原因**:
- **设计一致性**: 遵循Material Design设计规范
- **组件丰富**: 提供完整的UI组件库
- **主题支持**: 灵活的主题定制
- **无障碍支持**: 内置无障碍功能

#### 2.7.2 自定义组件
**祈福相关组件**:
- `BlessingCardView`: 祈福卡片展示
- `WishTreeView`: 愿望树动画组件
- `FloatingBlessingView`: 浮动祈福动画
- `ProgressIndicatorView`: 考试倒计时组件

### 2.8 测试框架

#### 2.8.1 单元测试
- **JUnit 4**: 基础单元测试框架
- **Mockito**: Mock框架，用于依赖模拟
- **Truth**: Google开发的断言库

#### 2.8.2 UI测试
- **Espresso**: Android UI自动化测试
- **UI Automator**: 跨应用UI测试
- **Fragment Testing**: Fragment单元测试

### 2.9 辅助工具

#### 2.9.1 代码质量
- **CheckStyle**: 代码风格检查
- **FindBugs**: 静态代码分析
- **SonarQube**: 代码质量管理

#### 2.9.2 性能监控
- **LeakCanary**: 内存泄漏检测
- **Stetho**: 调试工具
- **Firebase Crashlytics**: 崩溃报告

### 2.10 技术选型总结

| 类别 | 技术选择 | 版本 | 选择原因 |
|------|----------|------|----------|
| 开发语言 | Java | 8+ | 团队熟悉，生态成熟 |
| UI框架 | Android Native | - | 性能最优，功能完整 |
| 架构组件 | AAC | 2.x | Google官方推荐 |
| 依赖注入 | Dagger 2 | 2.44 | 编译时检查，性能优秀 |
| 网络请求 | Retrofit + OkHttp | 2.9 + 4.9 | 类型安全，功能强大 |
| 响应式编程 | RxJava 2 | 2.2 | 异步处理，数据流管理 |
| 数据库 | Room | 2.4 | SQLite抽象，LiveData集成 |
| 图片加载 | Glide | 4.14 | 内存效率，生命周期集成 |
| UI组件 | Material Components | 1.7 | 设计一致性，组件丰富 |
| 测试框架 | JUnit + Espresso | 4.13 + 3.4 | 完整测试方案 |

---

## 3. 模块划分与职责

### 3.1 整体模块架构

高考祈福Android应用采用**分层模块化**架构，将应用分为以下几个主要模块：

```
高考祈福 App
├── app (应用主模块)
├── common (公共模块) 
├── data (数据层模块)
├── domain (业务逻辑模块)
├── presentation (表现层模块)
├── network (网络模块)
├── database (数据库模块)
├── repository (数据仓库模块)
├── usecase (用例模块)
├── widget (自定义组件模块)
└── test (测试模块)
```

### 3.2 模块职责说明

#### 3.2.1 app
**职责**: 应用入口，管理应用生命周期

- 应用入口点，包含Application类
- 全局配置初始化
- 依赖注入组件初始化
- 全局异常处理设置
- 崩溃日志收集配置

**主要类**:
- `BlessingApplication`: 应用入口类
- `AppComponent`: Dagger应用级组件
- `AppModule`: 应用级依赖注入模块
- `CrashHandler`: 全局异常处理器

#### 3.2.2 common
**职责**: 存放全局公共类和工具方法

- 基础Activity、Fragment、Adapter类
- 公共工具类和扩展方法
- 常量定义
- 通用数据模型
- 公共资源管理

**主要包结构**:
- `base`: BaseActivity、BaseFragment等基础类
- `utils`: 工具类集合
- `constants`: 应用常量定义
- `extensions`: Kotlin扩展函数
- `managers`: 全局管理器类

#### 3.2.3 data
**职责**: 数据层实现，包括本地数据库和远程网络数据源

- 数据模型定义
- 数据源抽象接口实现
- 缓存策略管理
- 数据转换逻辑
- 数据持久化

**主要组件**:
- `entities`: 数据实体类
- `local`: 本地数据源实现
- `remote`: 远程数据源实现
- `cache`: 缓存实现
- `mappers`: 数据转换器

#### 3.2.4 domain
**职责**: 业务逻辑层，实现具体的业务用例

- 业务实体定义
- 业务规则实现
- 用例接口定义
- Repository接口定义
- 业务异常定义

**核心用例**:
- `GetBlessingsUseCase`: 获取祈福列表
- `CreateBlessingUseCase`: 创建祈福
- `LikeBlessingUseCase`: 点赞祈福
- `GetUserProfileUseCase`: 获取用户信息
- `LoginUseCase`: 用户登录

#### 3.2.5 presentation
**职责**: 表现层，实现UI界面和用户交互

- Activity和Fragment实现
- ViewModel实现
- UI适配器实现
- 自定义View组件
- 用户交互逻辑

**主要模块**:
- `main`: 主界面相关
- `blessing`: 祈福功能相关
- `user`: 用户中心相关
- `settings`: 设置页面相关
- `widgets`: 自定义UI组件

#### 3.2.6 network
**职责**: 网络请求相关类，封装Retrofit和OkHttp

- API接口定义
- 网络配置管理
- 请求拦截器实现
- 响应数据模型
- 网络状态监控

**核心功能**:
- API服务接口
- 网络请求配置
- Token认证管理
- 网络错误处理
- 请求日志记录

#### 3.2.7 database
**职责**: 数据库相关类，封装Room数据库操作

- 数据库实体定义
- DAO接口实现
- 数据库配置
- 数据库迁移
- 数据库工具类

**核心组件**:
- `entities`: Room实体类
- `dao`: 数据访问对象
- `database`: 数据库主类
- `migrations`: 数据库迁移
- `converters`: 类型转换器

#### 3.2.8 repository
**职责**: 数据仓库实现，协调本地和远程数据源

- Repository接口实现
- 数据源协调逻辑
- 缓存策略实现
- 数据同步逻辑
- 离线支持

**数据仓库**:
- `BlessingRepository`: 祈福数据仓库
- `UserRepository`: 用户数据仓库
- `ConfigRepository`: 配置数据仓库
- `StatisticsRepository`: 统计数据仓库

#### 3.2.9 usecase
**职责**: 用例实现，封装具体的业务场景

- 具体用例实现
- 业务逻辑编排
- 数据验证
- 异常处理
- 结果封装

**主要用例类**:
- 祈福相关用例
- 用户相关用例
- 内容管理用例
- 统计分析用例

#### 3.2.10 widget
**职责**: 自定义UI组件，实现特定的界面效果

- 祈福相关自定义组件
- 动画效果组件
- 图表展示组件
- 交互控件
- 装饰性组件

**自定义组件**:
- `BlessingCardView`: 祈福卡片
- `WishTreeView`: 愿望树
- `FloatingBlessingView`: 浮动祈福
- `CountdownView`: 考试倒计时
- `StatisticsChartView`: 统计图表

#### 3.2.11 test
**职责**: 单元测试和UI测试相关类

- 单元测试用例
- 集成测试用例
- UI测试用例
- Mock数据和工具
- 测试配置

### 3.3 模块依赖关系

```
app
├── presentation (依赖)
├── domain (依赖)
├── data (依赖)
├── common (依赖)
└── test (测试依赖)

presentation
├── domain (依赖)
├── common (依赖)
└── widget (依赖)

domain
└── common (依赖)

data
├── domain (依赖)
├── network (依赖)
├── database (依赖)
├── repository (依赖)
└── common (依赖)

repository
├── domain (依赖)
├── data (依赖)
├── usecase (依赖)
└── common (依赖)
```

---

## 4. 核心类图与包结构设计

### 4.1 整体包结构

```
com.mlinyun.gaokaoblessing
├── app/
│   ├── di/                     # 依赖注入相关
│   ├── config/                 # 应用配置
│   └── crash/                  # 崩溃处理
├── common/
│   ├── base/                   # 基础类
│   ├── utils/                  # 工具类
│   ├── constants/              # 常量定义
│   ├── extensions/             # 扩展函数
│   └── managers/               # 管理器类
├── data/
│   ├── local/                  # 本地数据源
│   ├── remote/                 # 远程数据源
│   ├── cache/                  # 缓存实现
│   └── mappers/                # 数据转换
├── domain/
│   ├── model/                  # 业务模型
│   ├── repository/             # Repository接口
│   ├── usecase/                # 用例接口
│   └── exception/              # 业务异常
├── presentation/
│   ├── viewmodel/              # ViewModel
│   ├── ui/                     # UI界面
│   ├── adapter/                # 适配器
│   └── dialog/                 # 对话框
├── network/
│   ├── api/                    # API接口
│   ├── interceptor/            # 拦截器
│   ├── response/               # 响应模型
│   └── config/                 # 网络配置
├── database/
│   ├── entity/                 # 数据库实体
│   ├── dao/                    # DAO接口
│   ├── migration/              # 数据库迁移
│   └── converter/              # 类型转换器
├── repository/
│   ├── impl/                   # Repository实现
│   ├── datasource/             # 数据源接口
│   └── strategy/               # 缓存策略
├── usecase/
│   ├── blessing/               # 祈福用例
│   ├── user/                   # 用户用例
│   ├── content/                # 内容用例
│   └── statistics/             # 统计用例
├── widget/
│   ├── blessing/               # 祈福组件
│   ├── animation/              # 动画组件
│   ├── chart/                  # 图表组件
│   └── decoration/             # 装饰组件
└── test/
    ├── unit/                   # 单元测试
    ├── integration/            # 集成测试
    ├── ui/                     # UI测试
    └── mock/                   # Mock工具
```

### 4.2 核心类图设计

#### 4.2.1 MVVM架构类图

```java
// ViewModel基类
public abstract class BaseViewModel extends ViewModel {
    protected CompositeDisposable compositeDisposable;
    protected MutableLiveData<Boolean> loading;
    protected MutableLiveData<String> error;
    
    protected void addDisposable(Disposable disposable);
    protected void handleError(Throwable throwable);
}

// 祈福ViewModel
public class BlessingViewModel extends BaseViewModel {
    private BlessingRepository blessingRepository;
    private GetBlessingsUseCase getBlessingsUseCase;
    private CreateBlessingUseCase createBlessingUseCase;
    
    private MutableLiveData<List<Blessing>> blessings;
    private MutableLiveData<Boolean> createSuccess;
    
    public void loadBlessings();
    public void createBlessing(String content);
    public void likeBlessing(int blessingId);
}

// Repository接口
public interface BlessingRepository {
    Observable<List<Blessing>> getBlessings(int page);
    Observable<Blessing> createBlessing(CreateBlessingRequest request);
    Observable<Boolean> likeBlessing(int blessingId);
    Observable<List<Blessing>> searchBlessings(String keyword);
}

// Repository实现
public class BlessingRepositoryImpl implements BlessingRepository {
    private BlessingApiService apiService;
    private BlessingDao blessingDao;
    private CacheManager cacheManager;
    
    // 实现接口方法
}
```

#### 4.2.2 数据层类图

```java
// 数据实体
@Entity(tableName = "blessing")
public class BlessingEntity {
    @PrimaryKey
    public int id;
    
    @ColumnInfo(name = "content")
    public String content;
    
    @ColumnInfo(name = "author_id")
    public int authorId;
    
    @ColumnInfo(name = "author_name")
    public String authorName;
    
    @ColumnInfo(name = "like_count")
    public int likeCount;
    
    @ColumnInfo(name = "comment_count")
    public int commentCount;
    
    @ColumnInfo(name = "created_at")
    public Date createdAt;
    
    @ColumnInfo(name = "updated_at")
    public Date updatedAt;
    
    @ColumnInfo(name = "is_liked")
    public boolean isLiked;
    
    @ColumnInfo(name = "image_url")
    public String imageUrl;
}

// DAO接口
@Dao
public interface BlessingDao {
    @Query("SELECT * FROM blessing ORDER BY created_at DESC LIMIT :limit OFFSET :offset")
    Observable<List<BlessingEntity>> getBlessings(int limit, int offset);
    
    @Query("SELECT * FROM blessing WHERE id = :id")
    Observable<BlessingEntity> getBlessingById(int id);
    
    @Query("SELECT * FROM blessing WHERE author_id = :authorId ORDER BY created_at DESC")
    Observable<List<BlessingEntity>> getBlessingsByAuthor(int authorId);
    
    @Query("SELECT * FROM blessing WHERE content LIKE '%' || :keyword || '%' ORDER BY created_at DESC")
    Observable<List<BlessingEntity>> searchBlessings(String keyword);
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertBlessings(List<BlessingEntity> blessings);
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    long insertBlessing(BlessingEntity blessing);
    
    @Update
    void updateBlessing(BlessingEntity blessing);
    
    @Delete
    void deleteBlessing(BlessingEntity blessing);
    
    @Query("DELETE FROM blessing WHERE id = :id")
    void deleteBlessingById(int id);
    
    @Query("DELETE FROM blessing")
    void deleteAllBlessings();
}

@Dao
public interface UserDao {
    @Query("SELECT * FROM user WHERE id = :id")
    Observable<UserEntity> getUserById(int id);
    
    @Query("SELECT * FROM user WHERE username = :username")
    Observable<UserEntity> getUserByUsername(String username);
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertUser(UserEntity user);
    
    @Update
    void updateUser(UserEntity user);
    
    @Delete
    void deleteUser(UserEntity user);
}
```

4. 定义数据库类

```java
@Database(
    entities = {BlessingEntity.class, UserEntity.class},
    version = 1,
    exportSchema = false
)
@TypeConverters({DateConverter.class})
public abstract class AppDatabase extends RoomDatabase {
    private static volatile AppDatabase INSTANCE;
    
    public abstract BlessingDao blessingDao();
    public abstract UserDao userDao();
    
    public static AppDatabase getInstance(Context context) {
        if (INSTANCE == null) {
            synchronized (AppDatabase.class) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(
                        context.getApplicationContext(),
                        AppDatabase.class,
                        "blessing_database"
                    )
                    .addMigrations(MIGRATION_1_2)
                    .build();
                }
            }
        }
        return INSTANCE;
    }
    
    // 类型转换器
    public static class DateConverter {
        @TypeConverter
        public static Date fromTimestamp(Long value) {
            return value == null ? null : new Date(value);
        }
        
        @TypeConverter
        public static Long dateToTimestamp(Date date) {
            return date == null ? null : date.getTime();
        }
    }
    
    // 数据库迁移
    static final Migration MIGRATION_1_2 = new Migration(1, 2) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            database.execSQL("ALTER TABLE blessing ADD COLUMN image_url TEXT");
        }
    };
}
```

#### 6.1.2 数据库迁移

**策略**：使用Room提供的数据库迁移功能

```java
public class DatabaseMigrations {
    // 版本1到版本2的迁移
    public static final Migration MIGRATION_1_2 = new Migration(1, 2) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            // 添加新字段
            database.execSQL("ALTER TABLE blessing ADD COLUMN image_url TEXT");
            database.execSQL("ALTER TABLE user ADD COLUMN school TEXT");
        }
    };
    
    // 版本2到版本3的迁移
    public static final Migration MIGRATION_2_3 = new Migration(2, 3) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            // 创建新表
            database.execSQL("CREATE TABLE comment (" +
                "id INTEGER PRIMARY KEY NOT NULL, " +
                "blessing_id INTEGER NOT NULL, " +
                "content TEXT NOT NULL, " +
                "author_id INTEGER NOT NULL, " +
                "created_at INTEGER NOT NULL)");
            
            // 创建索引
            database.execSQL("CREATE INDEX index_comment_blessing_id ON comment(blessing_id)");
        }
    };
    
    // 获取所有迁移
    public static Migration[] getAllMigrations() {
        return new Migration[]{MIGRATION_1_2, MIGRATION_2_3};
    }
}
```

### 6.2 网络数据缓存

#### 6.2.1 Retrofit + OkHttp

**用途**：远程数据获取和HTTP缓存

- Retrofit提供简洁的网络请求接口
- OkHttp提供强大的缓存机制和连接池管理
- 支持自定义拦截器处理认证和日志
- 自动处理JSON序列化和反序列化

1. 添加依赖

```groovy
dependencies {
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'
    implementation 'com.squareup.okhttp3:okhttp:4.9.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.9.0'
}
```

2. 定义API接口

```java
public interface BlessingApiService {
    @GET("blessings")
    Observable<ApiResponse<List<BlessingDto>>> getBlessings(
        @Query("page") int page,
        @Query("size") int size,
        @Query("category") String category
    );
    
    @GET("blessings/{id}")
    Observable<ApiResponse<BlessingDto>> getBlessingById(@Path("id") int id);
    
    @POST("blessings")
    Observable<ApiResponse<BlessingDto>> createBlessing(@Body CreateBlessingRequest request);
    
    @PUT("blessings/{id}/like")
    Observable<ApiResponse<Void>> toggleLike(@Path("id") int id);
    
    @GET("blessings/search")
    Observable<ApiResponse<List<BlessingDto>>> searchBlessings(
        @Query("keyword") String keyword,
        @Query("page") int page
    );
    
    @Multipart
    @POST("upload/image")
    Observable<ApiResponse<UploadResponse>> uploadImage(
        @Part MultipartBody.Part image
    );
}

public interface UserApiService {
    @POST("auth/register")
    Observable<ApiResponse<AuthResponse>> register(@Body RegisterRequest request);
    
    @POST("auth/login")
    Observable<ApiResponse<AuthResponse>> login(@Body LoginRequest request);
    
    @POST("auth/refresh")
    Observable<ApiResponse<AuthResponse>> refreshToken(@Body RefreshTokenRequest request);
    
    @GET("user/profile")
    Observable<ApiResponse<UserDto>> getUserProfile();
    
    @PUT("user/profile")
    Observable<ApiResponse<UserDto>> updateUserProfile(@Body UpdateProfileRequest request);
    
    @GET("user/blessings")
    Observable<ApiResponse<List<BlessingDto>>> getUserBlessings(
        @Query("page") int page
    );
}
```

3. 配置Retrofit

```java
@Module
public class NetworkModule {
    private static final String BASE_URL = BuildConfig.API_BASE_URL;
    private static final int CONNECT_TIMEOUT = 30;
    private static final int READ_TIMEOUT = 30;
    private static final int WRITE_TIMEOUT = 30;
    
    @Provides
    @Singleton
    public Gson provideGson() {
        return new GsonBuilder()
            .setDateFormat("yyyy-MM-dd HH:mm:ss")
            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
            .create();
    }
    
    @Provides
    @Singleton
    public OkHttpClient provideOkHttpClient(
        AuthInterceptor authInterceptor,
        LoggingInterceptor loggingInterceptor,
        CacheInterceptor cacheInterceptor,
        Context context
    ) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
            .connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)
            .readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)
            .writeTimeout(WRITE_TIMEOUT, TimeUnit.SECONDS)
            .addInterceptor(authInterceptor)
            .addInterceptor(cacheInterceptor);
        
        // 只在Debug模式下添加日志拦截器
        if (BuildConfig.DEBUG) {
            builder.addInterceptor(loggingInterceptor);
        }
        
        // 添加缓存
        File cacheDir = new File(context.getCacheDir(), "http-cache");
        Cache cache = new Cache(cacheDir, 50 * 1024 * 1024); // 50MB
        builder.cache(cache);
        
        return builder.build();
    }
    
    @Provides
    @Singleton
    public Retrofit provideRetrofit(OkHttpClient okHttpClient, Gson gson) {
        return new Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .build();
    }
    
    @Provides
    @Singleton
    public BlessingApiService provideBlessingApiService(Retrofit retrofit) {
        return retrofit.create(BlessingApiService.class);
    }
    
    @Provides
    @Singleton
    public UserApiService provideUserApiService(Retrofit retrofit) {
        return retrofit.create(UserApiService.class);
    }
}
```

#### 2.3.2 OkHttp 3

**功能特点**：
- 高效的HTTP客户端，支持连接池和GZIP压缩
- 强大的拦截器机制
- 内置缓存支持
- 支持HTTP/2和WebSocket

**OkHttp配置**：

```groovy
dependencies {
    implementation 'com.squareup.okhttp3:okhttp:4.9.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.9.0'
}
```

**OkHttpClient配置**：

```java
public class OkHttpClientProvider {
    
    public static OkHttpClient createClient(Context context) {
        return new OkHttpClient.Builder()
            .addInterceptor(new AuthInterceptor(context))
            .addInterceptor(new CacheInterceptor())
            .addInterceptor(createLoggingInterceptor())
            .addNetworkInterceptor(new NetworkCacheInterceptor())
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .retryOnConnectionFailure(true)
            .cache(createCache(context))
            .build();
    }
    
    private static HttpLoggingInterceptor createLoggingInterceptor() {
        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(BuildConfig.DEBUG ? 
            HttpLoggingInterceptor.Level.BODY : 
            HttpLoggingInterceptor.Level.NONE);
        return interceptor;
    }
    
    private static Cache createCache(Context context) {
        File cacheDir = new File(context.getCacheDir(), "http-cache");
        long cacheSize = 50 * 1024 * 1024; // 50MB
        return new Cache(cacheDir, cacheSize);
    }
}
```

**网络请求示例**：

```java
public class NetworkClient {
    private OkHttpClient client;
    
    public NetworkClient() {
        this.client = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build();
    }
    
    public void get(String url, Callback callback) {
        Request request = new Request.Builder()
            .url(url)
            .get()
            .build();
        
        client.newCall(request).enqueue(callback);
    }
    
    public void post(String url, RequestBody body, Callback callback) {
        Request request = new Request.Builder()
            .url(url)
            .post(body)
            .build();
        
        client.newCall(request).enqueue(callback);
    }
    
    public Observable<String> getAsync(String url) {
        return Observable.create(emitter -> {
            Request request = new Request.Builder()
                .url(url)
                .build();
            
            client.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    emitter.onError(e);
                }
                
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        emitter.onNext(response.body().string());
                        emitter.onComplete();
                    } else {
                        emitter.onError(new IOException("Request failed: " + response.code()));
                    }
                }
            });
        });
    }
}
```

### 7. 网络层架构

#### 7.1 网络请求流程

```
┌───────────────┐
│   用户操作      │
└───────┬───────┘
        ▼
┌───────────────┐
│    View层     │
│  (Activity/Fragment) │
└───────┬───────┘
        ▼
┌───────────────┐
│  ViewModel层  │
└───────┬───────┘
        ▼
┌───────────────┐
│   Repository   │
└───────┬───────┘
        ▼
┌───────────────┐
│   数据源层    │
│  (Local/Remote) │
└───────────────┘
```

1. **用户操作**: 用户在界面上进行操作，如点击按钮
2. **View层**: 接收用户操作，更新UI状态
3. **ViewModel层**: 处理业务逻辑，调用Repository获取数据
4. **Repository**: 作为数据源的统一入口，协调本地和远程数据
5. **数据源层**: 实际执行数据的增删改查操作，可以是本地数据库也可以是远程服务器

#### 7.2 网络请求实现

```java
public class BlessingRepositoryImpl implements BlessingRepository {
    private final BlessingDao blessingDao;
    private final BlessingApiService apiService;
    private final PreferencesManager preferencesManager;
    
    public BlessingRepositoryImpl(BlessingDao blessingDao, BlessingApiService apiService, PreferencesManager preferencesManager) {
        this.blessingDao = blessingDao;
        this.apiService = apiService;
        this.preferencesManager = preferencesManager;
    }
    
    @Override
    public Observable<List<Blessing>> getBlessings(int page) {
        return apiService.getBlessings(page)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .map(response -> response.getData())
            .doOnNext(blessings -> {
                // 缓存到本地
                blessingDao.insertBlessings(blessings);
            })
            .onErrorResumeNext(throwable -> {
                // 网络错误时加载本地缓存
                return blessingDao.getBlessings(page);
            });
    }
    
    @Override
    public Observable<Blessing> createBlessing(CreateBlessingRequest request) {
        return apiService.createBlessing(request)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .map(response -> {
                // 更新本地数据库
                blessingDao.insertBlessing(response.getData());
                return response.getData();
            });
    }
    
    @Override
    public Observable<Boolean> likeBlessing(int blessingId) {
        return apiService.likeBlessing(blessingId)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .map(response -> true)
            .onErrorReturnItem(false);
    }
}
```

#### 7.3 网络状态监控

```java
public class NetworkStateReceiver extends BroadcastReceiver {
    private List<NetworkStateListener> listeners = new ArrayList<>();
    
    @Override
    public void onReceive(Context context, Intent intent) {
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            boolean isConnected = NetworkUtils.isNetworkAvailable(context);
            boolean isWifi = NetworkUtils.isWifiConnected(context);
            
            NetworkState state = new NetworkState(isConnected, isWifi);
            
            for (NetworkStateListener listener : listeners) {
                listener.onNetworkStateChanged(state);
            }
        }
    }
    
    public void addListener(NetworkStateListener listener) {
        listeners.add(listener);
    }
    
    public void removeListener(NetworkStateListener listener) {
        listeners.remove(listener);
    }
    
    public interface NetworkStateListener {
        void onNetworkStateChanged(NetworkState state);
    }
    
    public static class NetworkState {
        private boolean isConnected;
        private boolean isWifi;
        
        public NetworkState(boolean isConnected, boolean isWifi) {
            this.isConnected = isConnected;
            this.isWifi = isWifi;
        }
        
        public boolean isConnected() {
            return isConnected;
        }
        
        public boolean isWifi() {
            return isWifi;
        }
        
        public boolean isMobile() {
            return isConnected && !isWifi;
        }
    }
}
```

### 8. 依赖注入方案

### 8.1 Dagger 2 架构设计

高考祈福应用使用 **Dagger 2** 作为依赖注入框架，实现组件间的解耦和依赖管理。

#### 8.1.1 依赖注入架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Application Component                     │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 ApplicationModule                       │ │
│  │   - Context                                            │ │
│  │   - SharedPreferences                                  │ │
│  │   - Application级别的单例                              │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              ├── provides ──┐
                              │              │
┌─────────────────────────────┼──────────────┼─────────────────┐
│        Data Component       │              │  Network Comp   │
│  ┌─────────────────────────┐│              │┌───────────────┐ │
│  │    DatabaseModule       ││              ││ NetworkModule │ │
│  │  - AppDatabase          ││              ││ - Retrofit    │ │
│  │  - DAOs                 ││              ││ - OkHttpClient│ │
│  │  - Repository           ││              ││ - ApiService  │ │
│  └─────────────────────────┘│              │└───────────────┘ │
└─────────────────────────────┼──────────────┼─────────────────┘
                              │              │
                              └── injects ───┘
                                     │
┌─────────────────────────────────────────────────────────────┐
│                    Activity Component                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                  ActivityModule                         │ │
│  │   - Activity Context                                   │ │
│  │   - ViewModels                                         │ │
│  │   - Presenters                                         │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 Component 设计

#### 8.2.1 Application Component

```java
@Singleton
@Component(modules = {
    ApplicationModule.class,
    DatabaseModule.class,
    NetworkModule.class
})
public interface ApplicationComponent {
    
    // 向子Component提供依赖
    Context getContext();
    Application getApplication();
    SharedPreferences getSharedPreferences();
    AppDatabase getAppDatabase();
    ApiManager getApiManager();
    
    // Repository层依赖
    BlessingRepository getBlessingRepository();
    UserRepository getUserRepository();
    
    // 注入Application
    void inject(GaoKaoBlessingApplication application);
    
    // 子Component构建器
    ActivityComponent.Builder activityComponentBuilder();
    ServiceComponent.Builder serviceComponentBuilder();
}
```

#### 8.2.2 Activity Component

```java
@ActivityScope
@Subcomponent(modules = {
    ActivityModule.class,
    ViewModelModule.class
})
public interface ActivityComponent {
    
    // 注入Activity
    void inject(MainActivity mainActivity);
    void inject(BlessingWallActivity blessingWallActivity);
    void inject(CreateBlessingActivity createBlessingActivity);
    void inject(PersonalCenterActivity personalCenterActivity);
    void inject(SettingsActivity settingsActivity);
    
    // 注入Fragment
    void inject(BlessingListFragment blessingListFragment);
    void inject(MyBlessingFragment myBlessingFragment);
    void inject(UserProfileFragment userProfileFragment);
    
    @Subcomponent.Builder
    interface Builder {
        @BindsInstance
        Builder activity(Activity activity);
        
        Builder activityModule(ActivityModule activityModule);
        ActivityComponent build();
    }
}
```

#### 8.2.3 Service Component

```java
@ServiceScope
@Subcomponent(modules = {ServiceModule.class})
public interface ServiceComponent {
    
    void inject(BlessingService blessingService);
    void inject(NotificationService notificationService);
    
    @Subcomponent.Builder
    interface Builder {
        @BindsInstance
        Builder service(Service service);
        
        ServiceComponent build();
    }
}
```

### 8.3 Module 设计

#### 8.3.1 Application Module

```java
@Module
public class ApplicationModule {
    private Application application;
    
    public ApplicationModule(Application application) {
        this.application = application;
    }
    
    @Provides
    @Singleton
    Application provideApplication() {
        return application;
    }
    
    @Provides
    @Singleton
    Context provideContext() {
        return application.getApplicationContext();
    }
    
    @Provides
    @Singleton
    SharedPreferences provideSharedPreferences(Context context) {
        return context.getSharedPreferences("gaokao_blessing_prefs", Context.MODE_PRIVATE);
    }
    
    @Provides
    @Singleton
    Gson provideGson() {
        return new GsonBuilder()
            .setDateFormat("yyyy-MM-dd HH:mm:ss")
            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
            .create();
    }
}
```

#### 8.3.2 Database Module

```java
@Module
public class DatabaseModule {
    
    @Provides
    @Singleton
    AppDatabase provideAppDatabase(Context context) {
        return Room.databaseBuilder(
                context.getApplicationContext(),
                AppDatabase.class,
                "gaokao_blessing_database"
            )
            .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
            .build();
    }
    
    @Provides
    @Singleton
    BlessingDao provideBlessingDao(AppDatabase database) {
        return database.blessingDao();
    }
    
    @Provides
    @Singleton
    UserDao provideUserDao(AppDatabase database) {
        return database.userDao();
    }
    
    @Provides
    @Singleton
    BlessingRepository provideBlessingRepository(
            BlessingDao blessingDao,
            BlessingApiService apiService,
            SharedPreferences prefs) {
        return new BlessingRepositoryImpl(blessingDao, apiService, prefs);
    }
    
    @Provides
    @Singleton
    UserRepository provideUserRepository(
            UserDao userDao,
            UserApiService apiService,
            SharedPreferences prefs) {
        return new UserRepositoryImpl(userDao, apiService, prefs);
    }
}
```

#### 8.3.3 Network Module

```java
@Module
public class NetworkModule {
    private static final String BASE_URL = "https://api.gaokao.blessing.com/v1/";
    
    @Provides
    @Singleton
    OkHttpClient provideOkHttpClient(Context context, SharedPreferences prefs) {
        return new OkHttpClient.Builder()
            .addInterceptor(new AuthInterceptor(prefs))
            .addInterceptor(new CacheInterceptor())
            .addInterceptor(new LoggingInterceptor())
            .cache(new Cache(new File(context.getCacheDir(), "http_cache"), 10 * 1024 * 1024))
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();
    }
    
    @Provides
    @Singleton
    Retrofit provideRetrofit(OkHttpClient okHttpClient, Gson gson) {
        return new Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .build();
    }
    
    @Provides
    @Singleton
    BlessingApiService provideBlessingApiService(Retrofit retrofit) {
        return retrofit.create(BlessingApiService.class);
    }
    
    @Provides
    @Singleton
    UserApiService provideUserApiService(Retrofit retrofit) {
        return retrofit.create(UserApiService.class);
    }
    
    @Provides
    @Singleton
    ApiManager provideApiManager(BlessingApiService blessingApiService, 
                                 UserApiService userApiService) {
        return new ApiManager(blessingApiService, userApiService);
    }
}
```

#### 8.3.4 Activity Module

```java
@Module
public class ActivityModule {
    private Activity activity;
    
    public ActivityModule(Activity activity) {
        this.activity = activity;
    }
    
    @Provides
    @ActivityScope
    Activity provideActivity() {
        return activity;
    }
    
    @Provides
    @ActivityScope
    Context provideActivityContext() {
        return activity;
    }
    
    @Provides
    @ActivityScope
    FragmentManager provideFragmentManager() {
        if (activity instanceof AppCompatActivity) {
            return ((AppCompatActivity) activity).getSupportFragmentManager();
        }
        throw new IllegalStateException("Activity must extend AppCompatActivity");
    }
}
```

#### 8.3.5 ViewModel Module

```java
@Module
public abstract class ViewModelModule {
    
    @Binds
    @IntoMap
    @ViewModelKey(MainViewModel.class)
    abstract ViewModel bindMainViewModel(MainViewModel mainViewModel);
    
    @Binds
    @IntoMap
    @ViewModelKey(BlessingWallViewModel.class)
    abstract ViewModel bindBlessingWallViewModel(BlessingWallViewModel blessingWallViewModel);
    
    @Binds
    @IntoMap
    @ViewModelKey(CreateBlessingViewModel.class)
    abstract ViewModel bindCreateBlessingViewModel(CreateBlessingViewModel createBlessingViewModel);
    
    @Binds
    @IntoMap
    @ViewModelKey(PersonalCenterViewModel.class)
    abstract ViewModel bindPersonalCenterViewModel(PersonalCenterViewModel personalCenterViewModel);
    
    @Binds
    @IntoMap
    @ViewModelKey(UserProfileViewModel.class)
    abstract ViewModel bindUserProfileViewModel(UserProfileViewModel userProfileViewModel);
    
    @Binds
    abstract ViewModelProvider.Factory bindViewModelFactory(ViewModelFactory factory);
}
```

### 8.4 自定义Scope和Annotation

#### 8.4.1 Activity Scope

```java
@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface ActivityScope {
}
```

#### 8.4.2 Service Scope

```java
@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface ServiceScope {
}
```

#### 8.4.3 ViewModel Key

```java
@Documented
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@MapKey
public @interface ViewModelKey {
    Class<? extends ViewModel> value();
}
```

### 8.5 Application 初始化

#### 8.5.1 Application 类

```java
public class GaoKaoBlessingApplication extends Application {
    private ApplicationComponent applicationComponent;
    
    @Override
    public void onCreate() {
        super.onCreate();
        
        // 初始化Dagger组件
        applicationComponent = DaggerApplicationComponent.builder()
            .applicationModule(new ApplicationModule(this))
            .build();
        
        applicationComponent.inject(this);
        
        // 初始化其他组件
        initializeOtherComponents();
    }
    
    public ApplicationComponent getApplicationComponent() {
        return applicationComponent;
    }
    
    private void initializeOtherComponents() {
        // 初始化日志
        // 初始化崩溃处理
        // 初始化图片加载
    }
}
```

#### 8.5.2 Base Activity

```java
public abstract class BaseActivity extends AppCompatActivity {
    protected ActivityComponent activityComponent;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 创建Activity级别的依赖注入组件
        GaoKaoBlessingApplication app = (GaoKaoBlessingApplication) getApplication();
        activityComponent = app.getApplicationComponent()
            .activityComponentBuilder()
            .activity(this)
            .activityModule(new ActivityModule(this))
            .build();
        
        // 执行依赖注入
        injectDependencies();
    }
    
    protected abstract void injectDependencies();
    
    protected ActivityComponent getActivityComponent() {
        return activityComponent;
    }
}
```

#### 8.5.3 具体Activity实现

```java
public class MainActivity extends BaseActivity {
    @Inject ViewModelProvider.Factory viewModelFactory;
    @Inject SharedPreferences sharedPreferences;
    
    private MainViewModel viewModel;
    
    @Override
    protected void injectDependencies() {
        getActivityComponent().inject(this);
    }
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // 创建ViewModel
        viewModel = new ViewModelProvider(this, viewModelFactory)
            .get(MainViewModel.class);
        
        initializeViews();
        observeViewModel();
    }
    
    private void initializeViews() {
        // 初始化视图
    }
    
    private void observeViewModel() {
        // 观察ViewModel数据变化
    }
}
```

### 8.6 ViewModelFactory 实现

```java
@Singleton
public class ViewModelFactory implements ViewModelProvider.Factory {
    private final Map<Class<? extends ViewModel>, Provider<ViewModel>> creators;
    
    @Inject
    public ViewModelFactory(Map<Class<? extends ViewModel>, Provider<ViewModel>> creators) {
        this.creators = creators;
    }
    
    @SuppressWarnings("unchecked")
    @NonNull
    @Override
    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
        Provider<? extends ViewModel> creator = creators.get(modelClass);
        if (creator == null) {
            for (Map.Entry<Class<? extends ViewModel>, Provider<ViewModel>> entry : creators.entrySet()) {
                if (modelClass.isAssignableFrom(entry.getKey())) {
                    creator = entry.getValue();
                    break;
                }
            }
        }
        if (creator == null) {
            throw new IllegalArgumentException("Unknown model class " + modelClass);
        }
        try {
            return (T) creator.get();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

### 8.7 依赖注入最佳实践

#### 8.7.1 依赖注入原则

1. **单一职责**: 每个Module只负责提供特定类型的依赖
2. **生命周期管理**: 合理使用Scope管理对象生命周期
3. **接口注入**: 优先注入接口而非具体实现
4. **避免循环依赖**: 通过合理的架构设计避免循环依赖

#### 8.7.2 性能优化建议

1. **延迟初始化**: 使用Provider<T>实现延迟初始化
2. **合理使用Singleton**: 只对真正需要单例的对象使用@Singleton
3. **Component缓存**: 合理缓存Component实例
4. **减少反射**: 避免在运行时进行过多的反射操作

---

## 9. 异常处理与日志策略

### 9.1 异常处理架构

#### 9.1.1 异常分类体系

```java
// 基础异常类
public abstract class BaseException extends Exception {
    protected int code;
    protected String message;
    protected long timestamp;
    
    public BaseException(int code, String message) {
        super(message);
        this.code = code;
        this.message = message;
        this.timestamp = System.currentTimeMillis();
    }
    
    public abstract String getErrorType();
    public abstract boolean isRetryable();
    
    // Getters
    public int getCode() { return code; }
    public String getMessage() { return message; }
    public long getTimestamp() { return timestamp; }
}

// 网络异常
public class NetworkException extends BaseException {
    public static final int NETWORK_TIMEOUT = 1001;
    public static final int NETWORK_UNAVAILABLE = 1002;
    public static final int SERVER_ERROR = 1003;
    
    public NetworkException(int code, String message) {
        super(code, message);
    }
    
    @Override
    public String getErrorType() {
        return "NETWORK_ERROR";
    }
    
    @Override
    public boolean isRetryable() {
        return code != SERVER_ERROR;
    }
}

// 业务异常
public class BusinessException extends BaseException {
    public static final int INVALID_PARAM = 2001;
    public static final int AUTHENTICATION_FAILED = 2002;
    public static final int PERMISSION_DENIED = 2003;
    public static final int RESOURCE_NOT_FOUND = 2004;
    
    public BusinessException(int code, String message) {
        super(code, message);
    }
    
    @Override
    public String getErrorType() {
        return "BUSINESS_ERROR";
    }
    
    @Override
    public boolean isRetryable() {
        return false;
    }
}
```

#### 9.1.2 全局异常处理器

```java
public class GlobalExceptionHandler implements Thread.UncaughtExceptionHandler {
    private static final String TAG = "GlobalExceptionHandler";
    private Thread.UncaughtExceptionHandler defaultHandler;
    private Context context;
    private Logger logger;
    
    public GlobalExceptionHandler(Context context, Logger logger) {
        this.context = context;
        this.logger = logger;
        this.defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
    }
    
    @Override
    public void uncaughtException(Thread thread, Throwable ex) {
        try {
            // 记录崩溃信息
            logCrashInfo(thread, ex);
            
            // 保存崩溃信息到本地
            saveCrashInfo(ex);
        } catch (Exception e) {
            logger.e(TAG, "Error in uncaughtException", e);
        } finally {
            // 调用系统默认处理器
            if (defaultHandler != null) {
                defaultHandler.uncaughtException(thread, ex);
            }
        }
    }
    
    private void logCrashInfo(Thread thread, Throwable ex) {
        logger.e(TAG, "Uncaught exception in thread " + thread.getName(), ex);
    }
    
    private void saveCrashInfo(Throwable ex) {
        try {
            CrashInfo crashInfo = new CrashInfo(ex, context);
            CrashFileManager.saveCrashInfo(context, crashInfo);
        } catch (Exception e) {
            logger.e(TAG, "Failed to save crash info", e);
        }
    }
}
```

### 9.2 日志系统设计

#### 9.2.1 日志等级定义

```java
public enum LogLevel {
    VERBOSE(0, "V"),
    DEBUG(1, "D"),
    INFO(2, "I"),
    WARN(3, "W"),
    ERROR(4, "E");
    
    private final int priority;
    private final String tag;
    
    LogLevel(int priority, String tag) {
        this.priority = priority;
        this.tag = tag;
    }
    
    public int getPriority() { return priority; }
    public String getTag() { return tag; }
}
```

#### 9.2.2 日志接口设计

```java
public interface Logger {
    void v(String tag, String message);
    void v(String tag, String message, Throwable throwable);
    
    void d(String tag, String message);
    void d(String tag, String message, Throwable throwable);
    
    void i(String tag, String message);
    void i(String tag, String message, Throwable throwable);
    
    void w(String tag, String message);
    void w(String tag, String message, Throwable throwable);
    
    void e(String tag, String message);
    void e(String tag, String message, Throwable throwable);
    
    void log(LogLevel level, String tag, String message);
    void log(LogLevel level, String tag, String message, Throwable throwable);
}
```

#### 9.2.3 日志实现类

```java
public class AndroidLogger implements Logger {
    private static final String TAG_PREFIX = "GaoKaoBlessing_";
    private LogLevel minLevel;
    private List<LogHandler> handlers;
    
    public AndroidLogger(LogLevel minLevel) {
        this.minLevel = minLevel;
        this.handlers = new ArrayList<>();
        
        // 添加默认处理器
        addHandler(new ConsoleLogHandler());
        addHandler(new FileLogHandler());
    }
    
    public void addHandler(LogHandler handler) {
        handlers.add(handler);
    }
    
    @Override
    public void log(LogLevel level, String tag, String message, Throwable throwable) {
        if (level.getPriority() < minLevel.getPriority()) {
            return;
        }
        
        String fullTag = TAG_PREFIX + tag;
        LogEntry entry = new LogEntry(level, fullTag, message, throwable);
        
        for (LogHandler handler : handlers) {
            try {
                handler.handle(entry);
            } catch (Exception e) {
                // 避免日志处理器异常影响主流程
                Log.e("AndroidLogger", "Log handler error", e);
            }
        }
    }
    
    // ...existing code...
}
```

---

## 10. 安全与权限管理策略

### 10.1 权限管理架构

#### 10.1.1 权限分类

```java
public class PermissionConstants {
    // 必要权限 - 应用核心功能必须的权限
    public static final String[] REQUIRED_PERMISSIONS = {
        Manifest.permission.INTERNET,
        Manifest.permission.ACCESS_NETWORK_STATE
    };
    
    // 可选权限 - 增强功能的权限
    public static final String[] OPTIONAL_PERMISSIONS = {
        Manifest.permission.CAMERA,
        Manifest.permission.READ_EXTERNAL_STORAGE,
        Manifest.permission.WRITE_EXTERNAL_STORAGE,
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION,
        Manifest.permission.VIBRATE,
        Manifest.permission.RECORD_AUDIO
    };
    
    // 敏感权限 - 需要特殊处理的权限
    public static final String[] SENSITIVE_PERMISSIONS = {
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.CAMERA,
        Manifest.permission.RECORD_AUDIO
    };
}
```

#### 10.1.2 权限管理器

```java
public class PermissionManager {
    private static final String TAG = "PermissionManager";
    private static final int PERMISSION_REQUEST_CODE = 1001;
    
    private Activity activity;
    private Logger logger;
    private Map<String, PermissionCallback> pendingRequests;
    
    public PermissionManager(Activity activity, Logger logger) {
        this.activity = activity;
        this.logger = logger;
        this.pendingRequests = new HashMap<>();
    }
    
    // 检查权限
    public boolean hasPermission(String permission) {
        return ContextCompat.checkSelfPermission(activity, permission) 
            == PackageManager.PERMISSION_GRANTED;
    }
    
    // 检查多个权限
    public boolean hasPermissions(String[] permissions) {
        for (String permission : permissions) {
            if (!hasPermission(permission)) {
                return false;
            }
        }
        return true;
    }
    
    // 请求权限
    public void requestPermission(String permission, PermissionCallback callback) {
        requestPermissions(new String[]{permission}, callback);
    }
    
    // 请求多个权限
    public void requestPermissions(String[] permissions, PermissionCallback callback) {
        List<String> deniedPermissions = new ArrayList<>();
        
        for (String permission : permissions) {
            if (!hasPermission(permission)) {
                deniedPermissions.add(permission);
            }
        }
        
        if (deniedPermissions.isEmpty()) {
            callback.onPermissionGranted(permissions);
            return;
        }
        
        String requestKey = generateRequestKey(permissions);
        pendingRequests.put(requestKey, callback);
        
        ActivityCompat.requestPermissions(
            activity,
            deniedPermissions.toArray(new String[0]),
            PERMISSION_REQUEST_CODE
        );
    }
    
    // 处理权限请求结果
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        if (requestCode != PERMISSION_REQUEST_CODE) {
            return;
        }
        
        String requestKey = generateRequestKey(permissions);
        PermissionCallback callback = pendingRequests.remove(requestKey);
        
        if (callback == null) {
            logger.w(TAG, "No callback found for permission request");
            return;
        }
        
        List<String> grantedPermissions = new ArrayList<>();
        List<String> deniedPermissions = new ArrayList<>();
        
        for (int i = 0; i < permissions.length; i++) {
            if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {
                grantedPermissions.add(permissions[i]);
            } else {
                deniedPermissions.add(permissions[i]);
            }
        }
        
        if (deniedPermissions.isEmpty()) {
            callback.onPermissionGranted(permissions);
        } else {
            callback.onPermissionDenied(
                deniedPermissions.toArray(new String[0]),
                shouldShowRationale(deniedPermissions.toArray(new String[0]))
            );
        }
    }
    
    private String generateRequestKey(String[] permissions) {
        Arrays.sort(permissions);
        return TextUtils.join(",", permissions);
    }
    
    private boolean shouldShowRationale(String[] permissions) {
        for (String permission : permissions) {
            if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) {
                return true;
            }
        }
        return false;
    }
    
    // 权限回调接口
    public interface PermissionCallback {
        void onPermissionGranted(String[] permissions);
        void onPermissionDenied(String[] permissions, boolean shouldShowRationale);
    }
}
```

### 10.2 数据安全策略

#### 10.2.1 敏感数据加密

```java
public class SecurityUtils {
    private static final String KEY_ALIAS = "GaoKaoBlessingKey";
    private static final String ANDROID_KEYSTORE = "AndroidKeyStore";
    private static final String AES_MODE = "AES/GCM/NoPadding";
    private static final String RSA_MODE = "RSA/ECB/PKCS1Padding";
    
    // 生成或获取密钥
    @TargetApi(Build.VERSION_CODES.M)
    private static SecretKey getOrCreateSecretKey() throws Exception {
        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEYSTORE);
        keyStore.load(null);
        
        if (keyStore.containsAlias(KEY_ALIAS)) {
            return (SecretKey) keyStore.getKey(KEY_ALIAS, null);
        }
        
        KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEYSTORE);
        KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(KEY_ALIAS,
                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setUserAuthenticationRequired(false);
        
        keyGenerator.init(builder.build());
        return keyGenerator.generateKey();
    }
    
    // 加密数据
    public static String encrypt(String data) throws Exception {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            return encryptWithKeystore(data);
        } else {
            return encryptWithAES(data);
        }
    }
    
    // 解密数据
    public static String decrypt(String encryptedData) throws Exception {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            return decryptWithKeystore(encryptedData);
        } else {
            return decryptWithAES(encryptedData);
        }
    }
    
    @TargetApi(Build.VERSION_CODES.M)
    private static String encryptWithKeystore(String data) throws Exception {
        SecretKey secretKey = getOrCreateSecretKey();
        Cipher cipher = Cipher.getInstance(AES_MODE);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        
        byte[] iv = cipher.getIV();
        byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        
        // 将IV和加密数据合并
        byte[] result = new byte[iv.length + encryptedData.length];
        System.arraycopy(iv, 0, result, 0, iv.length);
        System.arraycopy(encryptedData, 0, result, iv.length, encryptedData.length);
        
        return Base64.encodeToString(result, Base64.DEFAULT);
    }
    
    @TargetApi(Build.VERSION_CODES.M)
    private static String decryptWithKeystore(String encryptedData) throws Exception {
        byte[] data = Base64.decode(encryptedData, Base64.DEFAULT);
        
        // 分离IV和加密数据
        byte[] iv = new byte[12]; // GCM IV length
        byte[] encrypted = new byte[data.length - 12];
        System.arraycopy(data, 0, iv, 0, 12);
        System.arraycopy(data, 12, encrypted, 0, encrypted.length);
        
        SecretKey secretKey = getOrCreateSecretKey();
        Cipher cipher = Cipher.getInstance(AES_MODE);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);
        
        byte[] decryptedData = cipher.doFinal(encrypted);
        return new String(decryptedData, StandardCharsets.UTF_8);
    }
    
    // 低版本Android的AES加密
    private static String encryptWithAES(String data) throws Exception {
        // 实现传统AES加密，使用固定密钥或从用户输入派生
        return data; // 简化实现
    }
    
    private static String decryptWithAES(String encryptedData) throws Exception {
        // 实现传统AES解密
        return encryptedData; // 简化实现
    }
}
```

#### 10.2.2 网络安全配置

```java
public class NetworkSecurityConfig {
    
    // SSL证书验证
    public static class CustomTrustManager implements X509TrustManager {
        private X509TrustManager defaultTrustManager;
        
        public CustomTrustManager() throws Exception {
            TrustManagerFactory factory = TrustManagerFactory.getInstance(
                TrustManagerFactory.getDefaultAlgorithm());
            factory.init((KeyStore) null);
            
            for (TrustManager tm : factory.getTrustManagers()) {
                if (tm instanceof X509TrustManager) {
                    defaultTrustManager = (X509TrustManager) tm;
                    break;
                }
            }
        }
        
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) 
                throws CertificateException {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }
        
        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) 
                throws CertificateException {
            try {
                defaultTrustManager.checkServerTrusted(chain, authType);
            } catch (CertificateException e) {
                // 可以添加额外的证书验证逻辑
                throw e;
            }
        }
        
        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return defaultTrustManager.getAcceptedIssuers();
        }
    }
    
    // 证书固定
    public static CertificatePinner createCertificatePinner() {
        return new CertificatePinner.Builder()
            .add("api.gaokao.blessing.com", "sha256/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=")
            .build();
    }
}
```

### 10.3 API安全策略

#### 10.3.1 API签名验证

```java
public class ApiSignatureGenerator {
    private static final String ALGORITHM = "HmacSHA256";
    private static final String SECRET_KEY = "your_secret_key_here";
    
    // 生成API签名
    public static String generateSignature(String method, String url, Map<String, String> params, 
                                         long timestamp, String nonce) {
        try {
            // 构建待签名字符串
            String signString = buildSignString(method, url, params, timestamp, nonce);
            
            // 使用HMAC-SHA256算法签名
            Mac mac = Mac.getInstance(ALGORITHM);
            SecretKeySpec secretKeySpec = new SecretKeySpec(SECRET_KEY.getBytes(), ALGORITHM);
            mac.init(secretKeySpec);
            
            byte[] hash = mac.doFinal(signString.getBytes(StandardCharsets.UTF_8));
            return Base64.encodeToString(hash, Base64.NO_WRAP);
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate signature", e);
        }
    }
    
    private static String buildSignString(String method, String url, Map<String, String> params,
                                        long timestamp, String nonce) {
        StringBuilder sb = new StringBuilder();
        sb.append(method.toUpperCase()).append("&");
        sb.append(url).append("&");
        sb.append(timestamp).append("&");
        sb.append(nonce);
        
        if (params != null && !params.isEmpty()) {
            sb.append("&");
            
            // 参数按键名排序
            TreeMap<String, String> sortedParams = new TreeMap<>(params);
            List<String> paramStrings = new ArrayList<>();
            
            for (Map.Entry<String, String> entry : sortedParams.entrySet()) {
                paramStrings.add(entry.getKey() + "=" + entry.getValue());
            }
            
            sb.append(TextUtils.join("&", paramStrings));
        }
        
        return sb.toString();
    }
    
    // 生成随机字符串
    public static String generateNonce() {
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

#### 10.3.2 Token管理

```java
public class TokenManager {
    private static final String TAG = "TokenManager";
    private static final String PREF_ACCESS_TOKEN = "access_token";
    private static final String PREF_REFRESH_TOKEN = "refresh_token";
    private static final String PREF_TOKEN_EXPIRE_TIME = "token_expire_time";
    
    private SharedPreferences preferences;
    private SecurityUtils securityUtils;
    private Logger logger;
    
    public TokenManager(SharedPreferences preferences, SecurityUtils securityUtils, Logger logger) {
        this.preferences = preferences;
        this.securityUtils = securityUtils;
        this.logger = logger;
    }
    
    // 保存Token
    public void saveTokens(String accessToken, String refreshToken, long expiresIn) {
        try {
            long expireTime = System.currentTimeMillis() + (expiresIn * 1000);
            
            preferences.edit()
                .putString(PREF_ACCESS_TOKEN, SecurityUtils.encrypt(accessToken))
                .putString(PREF_REFRESH_TOKEN, SecurityUtils.encrypt(refreshToken))
                .putLong(PREF_TOKEN_EXPIRE_TIME, expireTime)
                .apply();
                
            logger.d(TAG, "Tokens saved successfully");
        } catch (Exception e) {
            logger.e(TAG, "Failed to save tokens", e);
        }
    }
    
    // 获取访问Token
    public String getAccessToken() {
        try {
            String encryptedToken = preferences.getString(PREF_ACCESS_TOKEN, null);
            if (encryptedToken != null) {
                return SecurityUtils.decrypt(encryptedToken);
            }
        } catch (Exception e) {
            logger.e(TAG, "Failed to decrypt access token", e);
        }
        return null;
    }
    
    // 获取刷新Token
    public String getRefreshToken() {
        try {
            String encryptedToken = preferences.getString(PREF_REFRESH_TOKEN, null);
            if (encryptedToken != null) {
                return SecurityUtils.decrypt(encryptedToken);
            }
        } catch (Exception e) {
            logger.e(TAG, "Failed to decrypt refresh token", e);
        }
        return null;
    }
    
    // 检查Token是否过期
    public boolean isTokenExpired() {
        long expireTime = preferences.getLong(PREF_TOKEN_EXPIRE_TIME, 0);
        return System.currentTimeMillis() >= expireTime - (5 * 60 * 1000); // 提前5分钟
    }
    
    // 清除Token
    public void clearTokens() {
        preferences.edit()
            .remove(PREF_ACCESS_TOKEN)
            .remove(PREF_REFRESH_TOKEN)
            .remove(PREF_TOKEN_EXPIRE_TIME)
            .apply();
        logger.d(TAG, "Tokens cleared");
    }
}
```

### 10.4 代码混淆配置

#### 10.4.1 ProGuard配置

```proguard
# 高考祈福应用ProGuard配置

# 基本配置
-dontusemixedcaseclassnames
-dontskipnonpubliclibraryclasses
-verbose

# 保留注解
-keepattributes *Annotation*
-keepattributes Signature
-keepattributes SourceFile,LineNumberTable

# 保留实体类
-keep class com.gaokao.blessing.data.entity.** { *; }
-keep class com.gaokao.blessing.data.dto.** { *; }

# 保留网络请求相关类
-keep class com.gaokao.blessing.network.** { *; }

# Retrofit配置
-dontwarn retrofit2.**
-keep class retrofit2.** { *; }
-keepattributes Signature
-keepattributes Exceptions

# OkHttp配置
-dontwarn okhttp3.**
-keep class okhttp3.** { *; }

# Gson配置
-keep class com.google.gson.** { *; }
-keep class sun.misc.Unsafe { *; }

# RxJava配置
-dontwarn io.reactivex.**
-keep class io.reactivex.** { *; }

# Dagger配置
-dontwarn dagger.internal.codegen.**
-keep class dagger.** { *; }

# Room配置
-keep class * extends androidx.room.RoomDatabase
-dontwarn androidx.room.paging.**

# 保留native方法
-keepclasseswithmembernames class * {
    native <methods>;
}

# 保留自定义View
-keep public class * extends android.view.View {
    public <init>(android.content.Context);
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
    public void set*(...);
    *** get*();
}
```

### 10.5 安全检查清单

#### 10.5.1 开发阶段安全检查

```java
public class SecurityChecker {
    private static final String TAG = "SecurityChecker";
    
    // 检查调试模式
    public static boolean isDebuggable(Context context) {
        return (context.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    }
    
    // 检查根权限
    public static boolean isRooted() {
        return checkRootMethod1() || checkRootMethod2() || checkRootMethod3();
    }
    
    private static boolean checkRootMethod1() {
        String buildTags = Build.TAGS;
        return buildTags != null && buildTags.contains("test-keys");
    }
    
    private static boolean checkRootMethod2() {
        String[] paths = {
            "/system/app/Superuser.apk",
            "/sbin/su",
            "/system/bin/su",
            "/system/xbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su",
            "/system/sd/xbin/su",
            "/system/bin/failsafe/su",
            "/data/local/su"
        };
        
        for (String path : paths) {
            if (new File(path).exists()) {
                return true;
            }
        }
        return false;
    }
    
    private static boolean checkRootMethod3() {
        Process process = null;
        try {
            process = Runtime.getRuntime().exec(new String[]{"which", "su"});
            BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));
            return in.readLine() != null;
        } catch (Throwable t) {
            return false;
        } finally {
            if (process != null) {
                process.destroy();
            }
        }
    }
    
    // 检查模拟器
    public static boolean isEmulator() {
        return Build.FINGERPRINT.startsWith("generic")
            || Build.FINGERPRINT.toLowerCase().contains("vbox")
            || Build.FINGERPRINT.toLowerCase().contains("test-keys")
            || Build.MODEL.contains("google_sdk")
            || Build.MODEL.contains("Emulator")
            || Build.SERIAL.equalsIgnoreCase("unknown")
            || Build.SERIAL.equalsIgnoreCase("android");
    }
}
```

#### 10.6 安全最佳实践

##### 10.6.1 安全开发原则

1. **最小权限原则**: 只申请应用必需的权限
2. **数据加密**: 敏感数据必须加密存储和传输
3. **输入验证**: 对所有用户输入进行验证和过滤
4. **安全通信**: 使用HTTPS和证书固定
5. **代码混淆**: 对发布版本进行代码混淆

##### 10.6.2 安全测试建议

1. **静态分析**: 使用工具检查代码安全问题
2. **动态测试**: 运行时安全测试
3. **渗透测试**: 模拟攻击场景
4. **第三方库安全**: 定期更新和检查第三方库
5. **安全审计**: 定期进行安全代码审计

---

## 11. 可测试性与可维护性设计

### 11.1 单元测试架构

#### 11.1.1 测试分层策略

```
┌─────────────────────────────────────────────────────────────┐
│                     UI 测试层                                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐│
│  │   Espresso      │  │   UI Automator  │  │   Robolectric   ││
│  │   UI 交互测试    │  │   跨应用测试     │  │   本地 UI 测试   ││
│  └─────────────────┘  └─────────────────┘  └─────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                   集成测试层                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐│
│  │  Repository     │  │   ViewModel     │  │   UseCase       ││
│  │  集成测试        │  │   集成测试       │  │   集成测试       ││
│  └─────────────────┘  └─────────────────┘  └─────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    单元测试层                                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐│
│  │   JUnit         │  │   Mockito       │  │   Truth         ││
│  │   基础单元测试   │  │   Mock 对象      │  │   断言库        ││
│  └─────────────────┘  └─────────────────┘  └─────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 11.1.2 测试工具配置

**build.gradle 测试依赖配置**：

```gradle
dependencies {
    // 单元测试
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:4.6.1'
    testImplementation 'org.mockito:mockito-inline:4.6.1'
    testImplementation 'com.google.truth:truth:1.1.3'
    testImplementation 'androidx.arch.core:core-testing:2.2.0'
    
    // Android 单元测试
    testImplementation 'org.robolectric:robolectric:4.8.1'
    
    // 集成测试
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation 'androidx.test.espresso:espresso-contrib:3.5.1'
    androidTestImplementation 'androidx.test.espresso:espresso-intents:3.5.1'
    androidTestImplementation 'androidx.test:runner:1.5.2'
    androidTestImplementation 'androidx.test:rules:1.5.0'
    
    // Room 测试
    testImplementation 'androidx.room:room-testing:2.5.0'
    
    // RxJava 测试
    testImplementation 'io.reactivex.rxjava2:rxjava:2.2.21'
    testImplementation 'com.squareup.okhttp3:mockwebserver:4.10.0'
}
```

### 11.2 Repository 层测试

#### 11.2.1 Repository 单元测试

```java
@RunWith(MockitoJUnitRunner.class)
public class BlessingRepositoryTest {
    
    @Mock
    private BlessingDao mockDao;
    
    @Mock
    private BlessingApiService mockApiService;
    
    @Mock
    private SharedPreferences mockPreferences;
    
    private BlessingRepositoryImpl repository;
    
    @Before
    public void setUp() {
        repository = new BlessingRepositoryImpl(mockDao, mockApiService, mockPreferences);
    }
    
    @Test
    public void getBlessings_shouldReturnCachedDataWhenAvailable() {
        // Given
        List<BlessingEntity> cachedBlessings = createTestBlessings();
        when(mockDao.getAllBlessings()).thenReturn(Observable.just(cachedBlessings));
        
        // When
        TestObserver<List<BlessingEntity>> testObserver = repository.getBlessings()
            .test();
        
        // Then
        testObserver.assertComplete();
        testObserver.assertNoErrors();
        testObserver.assertValue(cachedBlessings);
        
        verify(mockDao).getAllBlessings();
        verifyNoInteractions(mockApiService);
    }
    
    @Test
    public void createBlessing_shouldSaveToLocalAndRemote() {
        // Given
        BlessingEntity blessing = createTestBlessing();
        ApiResponse<BlessingDto> response = new ApiResponse<>(200, "Success", new BlessingDto());
        
        when(mockApiService.createBlessing(any(CreateBlessingRequest.class)))
            .thenReturn(Observable.just(response));
        when(mockDao.insert(any(BlessingEntity.class)))
            .thenReturn(Completable.complete());
        
        // When
        TestObserver<BlessingEntity> testObserver = repository.createBlessing(
            blessing.getContent(), blessing.getImageUrl())
            .test();
        
        // Then
        testObserver.assertComplete();
        testObserver.assertNoErrors();
        
        verify(mockApiService).createBlessing(any(CreateBlessingRequest.class));
        verify(mockDao).insert(any(BlessingEntity.class));
    }
    
    @Test
    public void createBlessing_shouldHandleNetworkError() {
        // Given
        String content = "Test blessing";
        String imageUrl = "test.jpg";
        IOException networkError = new IOException("Network error");
        
        when(mockApiService.createBlessing(any(CreateBlessingRequest.class)))
            .thenReturn(Observable.error(networkError));
        
        // When
        TestObserver<BlessingEntity> testObserver = repository.createBlessing(content, imageUrl)
            .test();
        
        // Then
        testObserver.assertNotComplete();
        testObserver.assertError(IOException.class);
        
        verify(mockApiService).createBlessing(any(CreateBlessingRequest.class));
        verifyNoInteractions(mockDao);
    }
    
    private List<BlessingEntity> createTestBlessings() {
        List<BlessingEntity> blessings = new ArrayList<>();
        for (int i = 1; i <= 3; i++) {
            BlessingEntity blessing = createTestBlessing();
            blessing.setId(i);
            blessing.setContent("Test blessing " + i);
            blessings.add(blessing);
        }
        return blessings;
    }
    
    private BlessingEntity createTestBlessing() {
        BlessingEntity blessing = new BlessingEntity();
        blessing.setContent("Test blessing");
        blessing.setImageUrl("test.jpg");
        blessing.setCreatedAt(new Date());
        return blessing;
    }
}
```

#### 11.2.2 数据库测试

```java
@RunWith(AndroidJUnit4.class)
public class BlessingDaoTest {
    
    private AppDatabase database;
    private BlessingDao blessingDao;
    
    @Before
    public void setUp() {
        Context context = ApplicationProvider.getApplicationContext();
        database = Room.inMemoryDatabaseBuilder(context, AppDatabase.class)
            .allowMainThreadQueries()
            .build();
        blessingDao = database.blessingDao();
    }
    
    @After
    public void tearDown() {
        database.close();
    }
    
    @Test
    public void insertAndGetBlessing() {
        // Given
        BlessingEntity blessing = createTestBlessing();
        
        // When
        blessingDao.insert(blessing).blockingAwait();
        List<BlessingEntity> result = blessingDao.getAllBlessings().blockingFirst();
        
        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getContent()).isEqualTo(blessing.getContent());
    }
    
    @Test
    public void deleteBlessingById() {
        // Given
        BlessingEntity blessing = createTestBlessing();
        blessing.setId(1);
        blessingDao.insert(blessing).blockingAwait();
        
        // When
        blessingDao.deleteById(1).blockingAwait();
        List<BlessingEntity> result = blessingDao.getAllBlessings().blockingFirst();
        
        // Then
        assertThat(result).isEmpty();
    }
    
    @Test
    public void searchBlessings() {
        // Given
        BlessingEntity blessing1 = createTestBlessing();
        blessing1.setContent("高考加油");
        
        BlessingEntity blessing2 = createTestBlessing();
        blessing2.setContent("考试顺利");
        
        blessingDao.insert(blessing1).blockingAwait();
        blessingDao.insert(blessing2).blockingAwait();
        
        // When
        List<BlessingEntity> result = blessingDao.searchBlessings("高考").blockingFirst();
        
        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getContent()).contains("高考");
    }
    
    private BlessingEntity createTestBlessing() {
        BlessingEntity blessing = new BlessingEntity();
        blessing.setContent("Test blessing");
        blessing.setUserId(1);
        blessing.setLikeCount(0);
        blessing.setCreatedAt(new Date());
        return blessing;
    }
}
```

### 11.3 ViewModel 测试

#### 11.3.1 ViewModel 单元测试

```java
@RunWith(MockitoJUnitRunner.class)
public class BlessingWallViewModelTest {
    
    @Rule
    public InstantTaskExecutorRule instantTaskExecutorRule = new InstantTaskExecutorRule();
    
    @Mock
    private BlessingRepository mockRepository;
    
    @Mock
    private UserRepository mockUserRepository;
    
    private BlessingWallViewModel viewModel;
    private TestScheduler testScheduler;
    
    @Before
    public void setUp() {
        testScheduler = new TestScheduler();
        RxJavaPlugins.setIoSchedulerHandler(scheduler -> testScheduler);
        RxJavaPlugins.setComputationSchedulerHandler(scheduler -> testScheduler);
        
        viewModel = new BlessingWallViewModel(mockRepository, mockUserRepository);
    }
    
    @After
    public void tearDown() {
        RxJavaPlugins.reset();
    }
    
    @Test
    public void loadBlessings_shouldUpdateLiveData() {
        // Given
        List<BlessingEntity> blessings = createTestBlessings();
        when(mockRepository.getBlessings()).thenReturn(Observable.just(blessings));
        
        // When
        viewModel.loadBlessings();
        testScheduler.triggerActions();
        
        // Then
        assertThat(viewModel.getBlessings().getValue()).isEqualTo(blessings);
        assertThat(viewModel.getIsLoading().getValue()).isFalse();
        assertThat(viewModel.getError().getValue()).isNull();
    }
    
    @Test
    public void loadBlessings_shouldHandleError() {
        // Given
        Exception error = new RuntimeException("Test error");
        when(mockRepository.getBlessings()).thenReturn(Observable.error(error));
        
        // When
        viewModel.loadBlessings();
        testScheduler.triggerActions();
        
        // Then
        assertThat(viewModel.getBlessings().getValue()).isNull();
        assertThat(viewModel.getIsLoading().getValue()).isFalse();
        assertThat(viewModel.getError().getValue()).isEqualTo("Test error");
    }
    
    @Test
    public void createBlessing_shouldUpdateBlessingsList() {
        // Given
        String content = "New blessing";
        String imageUrl = "new.jpg";
        BlessingEntity newBlessing = createTestBlessing();
        newBlessing.setContent(content);
        
        when(mockRepository.createBlessing(content, imageUrl))
            .thenReturn(Observable.just(newBlessing));
        when(mockRepository.getBlessings())
            .thenReturn(Observable.just(Arrays.asList(newBlessing)));
        
        // When
        viewModel.createBlessing(content, imageUrl);
        testScheduler.triggerActions();
        
        // Then
        verify(mockRepository).createBlessing(content, imageUrl);
        assertThat(viewModel.getBlessings().getValue()).contains(newBlessing);
    }
    
    @Test
    public void toggleLike_shouldUpdateLikeStatus() {
        // Given
        BlessingEntity blessing = createTestBlessing();
        blessing.setId(1);
        blessing.setLiked(false);
        blessing.setLikeCount(5);
        
        when(mockRepository.toggleLike(1)).thenReturn(Completable.complete());
        
        // When
        viewModel.toggleLike(blessing);
        testScheduler.triggerActions();
        
        // Then
        verify(mockRepository).toggleLike(1);
        // 验证UI状态更新
    }
    
    private List<BlessingEntity> createTestBlessings() {
        List<BlessingEntity> blessings = new ArrayList<>();
        for (int i = 1; i <= 3; i++) {
            BlessingEntity blessing = createTestBlessing();
            blessing.setId(i);
            blessing.setContent("Test blessing " + i);
            blessings.add(blessing);
        }
        return blessings;
    }
    
    private BlessingEntity createTestBlessing() {
        BlessingEntity blessing = new BlessingEntity();
        blessing.setContent("Test blessing");
        blessing.setUserId(1);
        blessing.setLikeCount(0);
        blessing.setLiked(false);
        blessing.setCreatedAt(new Date());
        return blessing;
    }
}
```

### 11.4 UI 测试

#### 11.4.1 Espresso UI 测试

```java
@RunWith(AndroidJUnit4.class)
@LargeTest
public class BlessingWallActivityTest {
    
    @Rule
    public ActivityScenarioRule<BlessingWallActivity> activityRule = 
        new ActivityScenarioRule<>(BlessingWallActivity.class);
    
    @Rule
    public GrantPermissionRule permissionRule = 
        GrantPermissionRule.grant(Manifest.permission.INTERNET);
    
    @Before
    public void setUp() {
        // 初始化测试数据
        insertTestData();
    }
    
    @Test
    public void blessingList_displaysCorrectly() {
        // 验证列表显示
        onView(withId(R.id.recyclerViewBlessings))
            .check(matches(isDisplayed()));
        
        // 验证第一个条目
        onView(withText("Test blessing 1"))
            .check(matches(isDisplayed()));
    }
    
    @Test
    public void createBlessing_opensCreateScreen() {
        // 点击创建按钮
        onView(withId(R.id.fabCreateBlessing))
            .perform(click());
        
        // 验证跳转到创建页面
        onView(withId(R.id.editTextContent))
            .check(matches(isDisplayed()));
    }
    
    @Test
    public void likeBlessing_updatesLikeCount() {
        // 点击点赞按钮
        onView(allOf(withId(R.id.buttonLike), hasSibling(withText("Test blessing 1"))))
            .perform(click());
        
        // 等待网络请求完成
        onView(isRoot()).perform(waitForView(withText("1"), 5000));
        
        // 验证点赞数更新
        onView(withText("1"))
            .check(matches(isDisplayed()));
    }
    
    @Test
    public void searchBlessing_filtersResults() {
        // 打开搜索
        onView(withId(R.id.menuSearch))
            .perform(click());
        
        // 输入搜索关键词
        onView(withId(androidx.appcompat.R.id.search_src_text))
            .perform(typeText("高考"), closeSoftKeyboard());
        
        // 验证搜索结果
        onView(withText("高考加油"))
            .check(matches(isDisplayed()));
        
        onView(withText("Test blessing 1"))
            .check(doesNotExist());
    }
    
    @Test
    public void pullToRefresh_refreshesList() {
        // 下拉刷新
        onView(withId(R.id.swipeRefreshLayout))
            .perform(swipeDown());
        
        // 验证刷新指示器显示
        onView(withId(R.id.swipeRefreshLayout))
            .check(matches(isRefreshing()));
        
        // 等待刷新完成
        onView(isRoot()).perform(waitForView(not(isRefreshing()), 5000));
        
        // 验证数据更新
        onView(withId(R.id.recyclerViewBlessings))
            .check(matches(hasChildCount(greaterThan(0))));
    }
    
    private void insertTestData() {
        // 插入测试数据到数据库
        // 或通过Mock服务返回测试数据
    }
    
    // 自定义ViewAction等待View出现
    public static ViewAction waitForView(final Matcher<View> viewMatcher, final long timeout) {
        return new ViewAction() {
            @Override
            public Matcher<View> getConstraints() {
                return isRoot();
            }
            
            @Override
            public String getDescription() {
                return "Wait for view matching " + viewMatcher;
            }
            
            @Override
            public void perform(UiController uiController, View view) {
                uiController.loopMainThreadUntilIdle();
                final long startTime = System.currentTimeMillis();
                final long endTime = startTime + timeout;
                
                do {
                    for (View child : TreeIterables.breadthFirstViewTraversal(view)) {
                        if (viewMatcher.matches(child)) {
                            return;
                        }
                    }
                    uiController.loopMainThreadForAtLeast(50);
                } while (System.currentTimeMillis() < endTime);
                
                throw new PerformException.Builder()
                    .withActionDescription(this.getDescription())
                    .withViewDescription(HumanReadables.describe(view))
                    .withCause(new TimeoutException())
                    .build();
            }
        };
    }
}
```

### 11.5 代码质量保证

#### 11.5.1 静态代码分析配置

**Checkstyle 配置 (checkstyle.xml)**：

```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="warning"/>
    <property name="fileExtensions" value="java, properties, xml"/>
    
    <!-- 文件头检查 -->
    <module name="Header">
        <property name="headerFile" value="${config_loc}/java.header"/>
        <property name="fileExtensions" value="java"/>
    </module>
    
    <!-- 文件大小检查 -->
    <module name="FileLength">
        <property name="max" value="2000"/>
    </module>
    
    <!-- 行长度检查 -->
    <module name="LineLength">
        <property name="max" value="120"/>
        <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
    </module>
    
    <module name="TreeWalker">
        <!-- 命名约定 -->
        <module name="ConstantName"/>
        <module name="LocalFinalVariableName"/>
        <module name="LocalVariableName"/>
        <module name="MemberName"/>
        <module name="MethodName"/>
        <module name="PackageName"/>
        <module name="ParameterName"/>
        <module name="StaticVariableName"/>
        <module name="TypeName"/>
        
        <!-- 导入检查 -->
        <module name="AvoidStarImport"/>
        <module name="IllegalImport"/>
        <module name="RedundantImport"/>
        <module name="UnusedImports"/>
        
        <!-- 大小检查 -->
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        <module name="ParameterNumber">
            <property name="max" value="7"/>
        </module>
        
        <!-- 空白检查 -->
        <module name="EmptyForIteratorPad"/>
        <module name="GenericWhitespace"/>
        <module name="MethodParamPad"/>
        <module name="NoWhitespaceAfter"/>
        <module name="NoWhitespaceBefore"/>
        <module name="OperatorWrap"/>
        <module name="ParenPad"/>
        <module name="TypecastParenPad"/>
        <module name="WhitespaceAfter"/>
        <module name="WhitespaceAround"/>
        
        <!-- 修饰符检查 -->
        <module name="ModifierOrder"/>
        <module name="RedundantModifier"/>
        
        <!-- 块检查 -->
        <module name="AvoidNestedBlocks"/>
        <module name="EmptyBlock"/>
        <module name="LeftCurly"/>
        <module name="NeedBraces"/>
        <module name="RightCurly"/>
        
        <!-- 代码风格检查 -->
        <module name="LineSeparator">
            <property name="lineSeparator" value="LF"/>
        </module>
        
        <!-- 复杂度 -->
        <module name="CyclomaticComplexity">
            <property name="max" value="10"/>
        </module>
        <module name="JavaNCSS">
            <property name="methodMaximum" value="50"/>
        </module>
        <module name="NPathComplexity">
            <property name="max" value="200"/>
        </module>
    </module>
</module>
```

#### 11.5.2 SonarQube 集成配置

**sonar-project.properties**：

```properties
# 项目基本信息
sonar.projectKey=gaokao-blessing-android
sonar.projectName=高考祈福 Android 应用
sonar.projectVersion=1.0

# 源码路径
sonar.sources=app/src/main/java
sonar.tests=app/src/test/java,app/src/androidTest/java

# 编译输出路径
sonar.java.binaries=app/build/intermediates/classes

# 测试报告路径
sonar.junit.reportPaths=app/build/test-results/testDebugUnitTest
sonar.coverage.jacoco.xmlReportPaths=app/build/reports/jacoco/testDebugUnitTestCoverage/testDebugUnitTestCoverage.xml

# 排除文件
sonar.exclusions=**/*Test.java,**/*Mock*.java,**/R.java,**/BuildConfig.java

# 质量门禁
sonar.qualitygate.wait=true
```

### 11.6 持续集成配置

#### 11.6.1 GitHub Actions CI 配置

**.github/workflows/android.yml**：

```yaml
name: Android CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: ~/.gradle/caches
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}
        restore-keys: ${{ runner.os }}-gradle
        
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
      
    - name: Run unit tests
      run: ./gradlew testDebugUnitTest
      
    - name: Generate test coverage report
      run: ./gradlew jacocoTestReport
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./app/build/reports/jacoco/testDebugUnitTestCoverage/testDebugUnitTestCoverage.xml
        
    - name: Run lint
      run: ./gradlew lintDebug
      
    - name: Upload lint results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: lint-results
        path: app/build/reports/lint-results-debug.html
        
    - name: Build APK
      run: ./gradlew assembleDebug
      
    - name: Upload APK
      uses: actions/upload-artifact@v3
      with:
        name: debug-apk
        path: app/build/outputs/apk/debug/app-debug.apk

  ui-test:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Run UI tests
      uses: reactivecircus/android-emulator-runner@v2
      with:
        api-level: 29
        script: ./gradlew connectedAndroidTest
```

---

## 12. 构建配置和多环境支持

### 12.1 多环境配置策略

#### 12.1.1 环境分类

高考祈福应用需要支持多个环境：
- **开发环境 (dev)**: 开发调试使用
- **测试环境 (test)**: 内部测试使用  
- **预发布环境 (staging)**: 生产前验证
- **生产环境 (prod)**: 正式发布版本

#### 12.1.2 Gradle 构建配置

```gradle
// app/build.gradle
android {
    compileSdk 34
    
    defaultConfig {
        applicationId "com.gaokao.blessing"
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0.0"
        
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        
        // 默认配置
        buildConfigField "String", "BASE_URL", "\"https://api.gaokao.blessing.com/\""
        buildConfigField "boolean", "DEBUG_MODE", "false"
        buildConfigField "String", "LOG_LEVEL", "\"INFO\""
    }
    
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
        
        release {
            storeFile file('release.keystore')
            storePassword System.getenv("KEYSTORE_PASSWORD")
            keyAlias 'gaokao_blessing'
            keyPassword System.getenv("KEY_PASSWORD")
        }
    }
    
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            debuggable true
            minifyEnabled false
            signingConfig signingConfigs.debug
            
            buildConfigField "String", "BASE_URL", "\"https://dev-api.gaokao.blessing.com/\""
            buildConfigField "boolean", "DEBUG_MODE", "true"
            buildConfigField "String", "LOG_LEVEL", "\"DEBUG\""
            buildConfigField "String", "APP_NAME", "\"高考祈福-Debug\""
            
            resValue "string", "app_name", "高考祈福-Debug"
            manifestPlaceholders = [
                app_icon: "@mipmap/ic_launcher_debug"
            ]
        }
        
        release {
            debuggable false
            minifyEnabled true
            shrinkResources true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            
            buildConfigField "String", "BASE_URL", "\"https://api.gaokao.blessing.com/\""
            buildConfigField "boolean", "DEBUG_MODE", "false"
            buildConfigField "String", "LOG_LEVEL", "\"ERROR\""
            buildConfigField "String", "APP_NAME", "\"高考祈福\""
            
            resValue "string", "app_name", "高考祈福"
            manifestPlaceholders = [
                app_icon: "@mipmap/ic_launcher"
            ]
        }
    }
    
    flavorDimensions "environment"
    
    productFlavors {
        dev {
            dimension "environment"
            applicationIdSuffix ".dev"
            versionNameSuffix "-dev"
            
            buildConfigField "String", "BASE_URL", "\"https://dev-api.gaokao.blessing.com/\""
            buildConfigField "String", "ENVIRONMENT", "\"dev\""
            buildConfigField "boolean", "ENABLE_MOCK", "true"
            
            resValue "string", "app_name", "高考祈福-Dev"
        }
        
        test {
            dimension "environment"
            applicationIdSuffix ".test"
            versionNameSuffix "-test"
            
            buildConfigField "String", "BASE_URL", "\"https://test-api.gaokao.blessing.com/\""
            buildConfigField "String", "ENVIRONMENT", "\"test\""
            buildConfigField "boolean", "ENABLE_MOCK", "false"
            
            resValue "string", "app_name", "高考祈福-Test"
        }
        
        staging {
            dimension "environment"
            applicationIdSuffix ".staging"
            versionNameSuffix "-staging"
            
            buildConfigField "String", "BASE_URL", "\"https://staging-api.gaokao.blessing.com/\""
            buildConfigField "String", "ENVIRONMENT", "\"staging\""
            buildConfigField "boolean", "ENABLE_MOCK", "false"
            
            resValue "string", "app_name", "高考祈福-Staging"
        }
        
        prod {
            dimension "environment"
            
            buildConfigField "String", "BASE_URL", "\"https://api.gaokao.blessing.com/\""
            buildConfigField "String", "ENVIRONMENT", "\"prod\""
            buildConfigField "boolean", "ENABLE_MOCK", "false"
            
            resValue "string", "app_name", "高考祈福"
        }
    }
    
    // 构建变体配置
    applicationVariants.all { variant ->
        variant.outputs.all {
            def buildType = variant.buildType.name
            def flavor = variant.flavorName
            def versionName = variant.versionName
            def date = new Date().format('yyyyMMdd-HHmm')
            
            outputFileName = "GaoKaoBlessing-${flavor}-${buildType}-${versionName}-${date}.apk"
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    
    buildFeatures {
        buildConfig true
        viewBinding true
        dataBinding true
    }
    
    testOptions {
        unitTests {
            includeAndroidResources = true
            returnDefaultValues = true
        }
    }
}
```

### 12.2 配置管理系统

#### 12.2.1 配置管理器

```java
// 配置管理器
public class ConfigManager {
    private static ConfigManager instance;
    private final String environment;
    private final Map<String, Object> configs;
    
    private ConfigManager() {
        this.environment = BuildConfig.ENVIRONMENT;
        this.configs = new HashMap<>();
        loadConfigs();
    }
    
    public static ConfigManager getInstance() {
        if (instance == null) {
            synchronized (ConfigManager.class) {
                if (instance == null) {
                    instance = new ConfigManager();
                }
            }
        }
        return instance;
    }
    
    private void loadConfigs() {
        // 加载基础配置
        configs.put("base_url", BuildConfig.BASE_URL);
        configs.put("debug_mode", BuildConfig.DEBUG_MODE);
        configs.put("log_level", BuildConfig.LOG_LEVEL);
        configs.put("enable_mock", BuildConfig.ENABLE_MOCK);
        
        // 根据环境加载特定配置
        loadEnvironmentConfigs();
    }
    
    private void loadEnvironmentConfigs() {
        switch (environment) {
            case "dev":
                loadDevConfigs();
                break;
            case "test":
                loadTestConfigs();
                break;
            case "staging":
                loadStagingConfigs();
                break;
            case "prod":
                loadProdConfigs();
                break;
        }
    }
    
    private void loadDevConfigs() {
        configs.put("api_timeout", 30000);
        configs.put("cache_duration", 300); // 5分钟
        configs.put("log_file_enabled", true);
        configs.put("crash_report_enabled", false);
        configs.put("analytics_enabled", false);
    }
    
    private void loadTestConfigs() {
        configs.put("api_timeout", 20000);
        configs.put("cache_duration", 600); // 10分钟
        configs.put("log_file_enabled", true);
        configs.put("crash_report_enabled", true);
        configs.put("analytics_enabled", false);
    }
    
    private void loadStagingConfigs() {
        configs.put("api_timeout", 15000);
        configs.put("cache_duration", 1800); // 30分钟
        configs.put("log_file_enabled", false);
        configs.put("crash_report_enabled", true);
        configs.put("analytics_enabled", true);
    }
    
    private void loadProdConfigs() {
        configs.put("api_timeout", 10000);
        configs.put("cache_duration", 3600); // 1小时
        configs.put("log_file_enabled", false);
        configs.put("crash_report_enabled", true);
        configs.put("analytics_enabled", true);
    }
    
    // 获取配置方法
    public String getString(String key) {
        return (String) configs.get(key);
    }
    
    public boolean getBoolean(String key) {
        return (Boolean) configs.getOrDefault(key, false);
    }
    
    public int getInt(String key) {
        return (Integer) configs.getOrDefault(key, 0);
    }
    
    public String getBaseUrl() {
        return getString("base_url");
    }
    
    public boolean isDebugMode() {
        return getBoolean("debug_mode");
    }
    
    public boolean isMockEnabled() {
        return getBoolean("enable_mock");
    }
    
    public String getEnvironment() {
        return environment;
    }
}
```

#### 12.2.2 环境配置工厂

```java
// 环境配置工厂
public abstract class EnvironmentConfigFactory {
    
    public static EnvironmentConfig create() {
        String environment = BuildConfig.ENVIRONMENT;
        switch (environment) {
            case "dev":
                return new DevEnvironmentConfig();
            case "test":
                return new TestEnvironmentConfig();
            case "staging":
                return new StagingEnvironmentConfig();
            case "prod":
                return new ProdEnvironmentConfig();
            default:
                throw new IllegalArgumentException("Unknown environment: " + environment);
        }
    }
}

// 环境配置接口
public interface EnvironmentConfig {
    String getBaseUrl();
    int getApiTimeout();
    boolean isLoggingEnabled();
    boolean isCrashReportEnabled();
    boolean isAnalyticsEnabled();
    LogLevel getLogLevel();
}

// 开发环境配置
public class DevEnvironmentConfig implements EnvironmentConfig {
    @Override
    public String getBaseUrl() {
        return "https://dev-api.gaokao.blessing.com/";
    }
    
    @Override
    public int getApiTimeout() {
        return 30000; // 30秒
    }
    
    @Override
    public boolean isLoggingEnabled() {
        return true;
    }
    
    @Override
    public boolean isCrashReportEnabled() {
        return false;
    }
    
    @Override
    public boolean isAnalyticsEnabled() {
        return false;
    }
    
    @Override
    public LogLevel getLogLevel() {
        return LogLevel.DEBUG;
    }
}

// 生产环境配置
public class ProdEnvironmentConfig implements EnvironmentConfig {
    @Override
    public String getBaseUrl() {
        return "https://api.gaokao.blessing.com/";
    }
    
    @Override
    public int getApiTimeout() {
        return 10000; // 10秒
    }
    
    @Override
    public boolean isLoggingEnabled() {
        return false;
    }
    
    @Override
    public boolean isCrashReportEnabled() {
        return true;
    }
    
    @Override
    public boolean isAnalyticsEnabled() {
        return true;
    }
    
    @Override
    public LogLevel getLogLevel() {
        return LogLevel.ERROR;
    }
}
```

### 12.3 资源管理策略

#### 12.3.1 多环境资源配置

```xml
<!-- src/dev/res/values/config.xml -->
<resources>
    <string name="app_name">高考祈福-Dev</string>
    <string name="server_url">https://dev-api.gaokao.blessing.com</string>
    <bool name="enable_debug_menu">true</bool>
    <integer name="api_timeout">30000</integer>
    <color name="primary_color">#FF9800</color> <!-- 橙色表示开发环境 -->
</resources>

<!-- src/test/res/values/config.xml -->
<resources>
    <string name="app_name">高考祈福-Test</string>
    <string name="server_url">https://test-api.gaokao.blessing.com</string>
    <bool name="enable_debug_menu">true</bool>
    <integer name="api_timeout">20000</integer>
    <color name="primary_color">#2196F3</color> <!-- 蓝色表示测试环境 -->
</resources>

<!-- src/staging/res/values/config.xml -->
<resources>
    <string name="app_name">高考祈福-Staging</string>
    <string name="server_url">https://staging-api.gaokao.blessing.com</string>
    <bool name="enable_debug_menu">false</bool>
    <integer name="api_timeout">15000</integer>
    <color name="primary_color">#FF5722</color> <!-- 深橙色表示预发布环境 -->
</resources>

<!-- src/prod/res/values/config.xml -->
<resources>
    <string name="app_name">高考祈福</string>
    <string name="server_url">https://api.gaokao.blessing.com</string>
    <bool name="enable_debug_menu">false</bool>
    <integer name="api_timeout">10000</integer>
    <color name="primary_color">#E91E63</color> <!-- 粉色表示生产环境 -->
</resources>
```

#### 12.3.2 多环境图标配置

```xml
<!-- src/debug/AndroidManifest.xml -->
<application
    android:icon="@mipmap/ic_launcher_debug"
    android:label="@string/app_name">
</application>

<!-- src/main/AndroidManifest.xml -->
<application
    android:icon="${app_icon}"
    android:label="@string/app_name">
</application>
```

### 12.4 网络配置管理

#### 12.4.1 网络环境配置

```java
// 网络配置管理器
public class NetworkConfigManager {
    private final EnvironmentConfig environmentConfig;
    
    public NetworkConfigManager(EnvironmentConfig environmentConfig) {
        this.environmentConfig = environmentConfig;
    }
    
    public OkHttpClient createOkHttpClient() {
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(environmentConfig.getApiTimeout(), TimeUnit.MILLISECONDS)
                .readTimeout(environmentConfig.getApiTimeout(), TimeUnit.MILLISECONDS)
                .writeTimeout(environmentConfig.getApiTimeout(), TimeUnit.MILLISECONDS);
        
        // 添加拦截器
        if (environmentConfig.isLoggingEnabled()) {
            builder.addInterceptor(createLoggingInterceptor());
        }
        
        // 添加缓存拦截器
        builder.addInterceptor(createCacheInterceptor());
        
        // 生产环境添加证书绑定
        if ("prod".equals(BuildConfig.ENVIRONMENT)) {
            builder.certificatePinner(createCertificatePinner());
        }
        
        return builder.build();
    }
    
    private HttpLoggingInterceptor createLoggingInterceptor() {
        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        if (BuildConfig.DEBUG) {
            interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        } else {
            interceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
        }
        return interceptor;
    }
    
    private Interceptor createCacheInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {
                Request request = chain.request();
                
                // 添加环境标识头
                request = request.newBuilder()
                        .addHeader("X-Environment", BuildConfig.ENVIRONMENT)
                        .addHeader("X-Version", BuildConfig.VERSION_NAME)
                        .build();
                
                return chain.proceed(request);
            }
        };
    }
    
    private CertificatePinner createCertificatePinner() {
        return new CertificatePinner.Builder()
                .add("api.gaokao.blessing.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
                .build();
    }
}
```

### 12.5 数据库配置管理

#### 12.5.1 多环境数据库配置

```java
// 数据库配置管理器
public class DatabaseConfigManager {
    
    public static String getDatabaseName() {
        switch (BuildConfig.ENVIRONMENT) {
            case "dev":
                return "gaokao_blessing_dev.db";
            case "test":
                return "gaokao_blessing_test.db";
            case "staging":
                return "gaokao_blessing_staging.db";
            case "prod":
                return "gaokao_blessing.db";
            default:
                return "gaokao_blessing.db";
        }
    }
    
    public static boolean isDebuggingEnabled() {
        return BuildConfig.DEBUG_MODE;
    }
    
    public static RoomDatabase.Builder<AppDatabase> configureDatabase(
            RoomDatabase.Builder<AppDatabase> builder) {
        
        if (isDebuggingEnabled()) {
            builder.fallbackToDestructiveMigration(); // 开发环境允许销毁重建
        }
        
        // 根据环境配置预填充数据
        if ("dev".equals(BuildConfig.ENVIRONMENT) || "test".equals(BuildConfig.ENVIRONMENT)) {
            builder.addCallback(new DevDatabaseCallback());
        }
        
        return builder;
    }
    
    // 开发环境数据库回调
    private static class DevDatabaseCallback extends RoomDatabase.Callback {
        @Override
        public void onCreate(@NonNull SupportSQLiteDatabase db) {
            super.onCreate(db);
            // 插入测试数据
            insertTestData(db);
        }
        
        private void insertTestData(SupportSQLiteDatabase db) {
            // 插入测试用户数据
            db.execSQL("INSERT INTO users (id, name, school, grade) VALUES " +
                    "(1, '测试用户1', '测试高中', '高三'), " +
                    "(2, '测试用户2', '示例中学', '高二')");
            
            // 插入测试祈福数据
            db.execSQL("INSERT INTO wishes (id, user_id, content, type, created_at) VALUES " +
                    "(1, 1, '希望高考顺利', 'EXAM', '2024-01-01 00:00:00'), " +
                    "(2, 2, '希望考上理想大学', 'UNIVERSITY', '2024-01-01 00:00:00')");
        }
    }
}
```

### 12.6 构建脚本优化

#### 12.6.1 Gradle 性能优化

```gradle
// gradle.properties
# 启用并行构建
org.gradle.parallel=true
# 启用构建缓存
org.gradle.caching=true
# 启用配置缓存
org.gradle.configuration-cache=true
# 增加堆内存
org.gradle.jvmargs=-Xmx4g -Dfile.encoding=UTF-8

# Android 构建优化
android.useAndroidX=true
android.enableJetifier=true
android.enableR8.fullMode=true
android.enableBuildCache=true
```

#### 12.6.2 构建任务脚本

```gradle
// 自定义构建任务
task buildAllVariants {
    group 'build'
    description '构建所有变体'
    
    dependsOn 'assembleDevDebug', 'assembleTestDebug', 'assembleStagingRelease', 'assembleProdRelease'
}

task generateBuildInfo {
    group 'build'
    description '生成构建信息'
    
    doLast {
        def buildInfo = [
            buildTime: new Date().format('yyyy-MM-dd HH:mm:ss'),
            gitCommit: 'git rev-parse HEAD'.execute().text.trim(),
            buildNumber: System.getenv('BUILD_NUMBER') ?: 'local',
            environment: project.hasProperty('environment') ? project.environment : 'dev'
        ]
        
        def buildInfoFile = new File(project.buildDir, 'build-info.json')
        buildInfoFile.text = groovy.json.JsonBuilder(buildInfo).toPrettyString()
    }
}

// 自动版本号管理
def getVersionCode() {
    def versionPropsFile = file('version.properties')
    def versionCode = 1
    
    if (versionPropsFile.exists()) {
        def props = new Properties()
        props.load(new FileInputStream(versionPropsFile))
        versionCode = props['VERSION_CODE'].toInteger()
    }
    
    return versionCode
}

def updateVersionCode() {
    def versionPropsFile = file('version.properties')
    def versionCode = getVersionCode() + 1
    
    def props = new Properties()
    props['VERSION_CODE'] = versionCode.toString()
    props.store(versionPropsFile.newWriter(), null)
    
    return versionCode
}
```

### 12.7 持续集成配置

#### 12.7.1 GitHub Actions 多环境构建

```yaml
# .github/workflows/multi-env-build.yml
name: Multi-Environment Build

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-dev:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Build Dev APK
      run: ./gradlew assembleDevDebug
      
    - name: Upload Dev APK
      uses: actions/upload-artifact@v3
      with:
        name: dev-apk
        path: app/build/outputs/apk/dev/debug/*.apk

  build-staging:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Build Staging APK
      run: ./gradlew assembleStagingRelease
      env:
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        
    - name: Upload Staging APK
      uses: actions/upload-artifact@v3
      with:
        name: staging-apk
        path: app/build/outputs/apk/staging/release/*.apk

  build-production:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Build Production APK
      run: ./gradlew assembleProdRelease
      env:
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false
```

### 12.8 配置管理最佳实践

#### 12.8.1 配置安全性

1. **敏感信息管理**
   - 使用环境变量存储密钥
   - 避免在代码中硬编码敏感信息
   - 使用 keystore 文件保护签名密钥

2. **配置验证**
   - 应用启动时验证配置完整性
   - 提供配置错误的友好提示
   - 实现配置回退机制

#### 12.8.2 部署策略

1. **自动化部署**
   - 基于分支自动选择环境
   - 实现一键部署脚本
   - 集成自动化测试

2. **版本管理**
   - 使用语义化版本号
   - 自动生成构建号
   - 维护版本发布日志

---
